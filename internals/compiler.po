# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2022, Python Software Foundation
# This file is distributed under the same license as the Python Developer's
# Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Developer's Guide\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-08 22:51-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../internals/compiler.rst:5
msgid "Compiler Design"
msgstr ""

#: ../../internals/compiler.rst:10
msgid "Abstract"
msgstr ""

#: ../../internals/compiler.rst:12
msgid ""
"In CPython, the compilation from source code to bytecode involves several "
"steps:"
msgstr ""

#: ../../internals/compiler.rst:14
msgid "Tokenize the source code (:file:`Parser/tokenizer.c`)"
msgstr ""

#: ../../internals/compiler.rst:15
msgid ""
"Parse the stream of tokens into an Abstract Syntax Tree (:file:`Parser/"
"parser.c`)"
msgstr ""

#: ../../internals/compiler.rst:16
msgid "Transform AST into a Control Flow Graph (:file:`Python/compile.c`)"
msgstr ""

#: ../../internals/compiler.rst:17
msgid ""
"Emit bytecode based on the Control Flow Graph (:file:`Python/compile.c`)"
msgstr ""

#: ../../internals/compiler.rst:19
msgid ""
"The purpose of this document is to outline how these steps of the process "
"work."
msgstr ""

#: ../../internals/compiler.rst:21
msgid ""
"This document does not touch on how parsing works beyond what is needed to "
"explain what is needed for compilation.  It is also not exhaustive in terms "
"of the how the entire system works.  You will most likely need to read some "
"source to have an exact understanding of all details."
msgstr ""

#: ../../internals/compiler.rst:28
msgid "Parsing"
msgstr ""

#: ../../internals/compiler.rst:30
msgid ""
"As of Python 3.9, Python's parser is a PEG parser of a somewhat unusual "
"design (since its input is a stream of tokens rather than a stream of "
"characters as is more common with PEG parsers)."
msgstr ""

#: ../../internals/compiler.rst:34
msgid ""
"The grammar file for Python can be found in :file:`Grammar/python.gram`.  "
"The definitions for literal tokens (such as ``:``, numbers, etc.) can be "
"found in :file:`Grammar/Tokens`. Various C files, including :file:`Parser/"
"parser.c` are generated from these (see :ref:`grammar`)."
msgstr ""

#: ../../internals/compiler.rst:42
msgid "Abstract Syntax Trees (AST)"
msgstr ""

#: ../../internals/compiler.rst:-1
msgid "Green Tree Snakes"
msgstr ""

#: ../../internals/compiler.rst:48
msgid ""
"See also `Green Tree Snakes - the missing Python AST docs <https://"
"greentreesnakes.readthedocs.io/en/latest/>`_ by Thomas Kluyver."
msgstr ""

#: ../../internals/compiler.rst:51
msgid ""
"The abstract syntax tree (AST) is a high-level representation of the program "
"structure without the necessity of containing the source code; it can be "
"thought of as an abstract representation of the source code.  The "
"specification of the AST nodes is specified using the Zephyr Abstract Syntax "
"Definition Language (ASDL) [Wang97]_."
msgstr ""

#: ../../internals/compiler.rst:57
msgid ""
"The definition of the AST nodes for Python is found in the file :file:"
"`Parser/Python.asdl`."
msgstr ""

#: ../../internals/compiler.rst:60
msgid ""
"Each AST node (representing statements, expressions, and several specialized "
"types, like list comprehensions and exception handlers) is defined by the "
"ASDL.  Most definitions in the AST correspond to a particular source "
"construct, such as an 'if' statement or an attribute lookup.  The definition "
"is independent of its realization in any particular programming language."
msgstr ""

#: ../../internals/compiler.rst:67
msgid ""
"The following fragment of the Python ASDL construct demonstrates the "
"approach and syntax::"
msgstr ""

#: ../../internals/compiler.rst:78
msgid ""
"The preceding example describes two different kinds of statements and an "
"expression: function definitions, return statements, and yield expressions. "
"All three kinds are considered of type ``stmt`` as shown by ``|`` separating "
"the various kinds.  They all take arguments of various kinds and amounts."
msgstr ""

#: ../../internals/compiler.rst:83
msgid ""
"Modifiers on the argument type specify the number of values needed; ``?`` "
"means it is optional, ``*`` means 0 or more, while no modifier means only "
"one value for the argument and it is required.  ``FunctionDef``, for "
"instance, takes an ``identifier`` for the *name*, ``arguments`` for *args*, "
"zero or more ``stmt`` arguments for *body*, and zero or more ``expr`` "
"arguments for *decorators*."
msgstr ""

#: ../../internals/compiler.rst:90
msgid ""
"Do notice that something like 'arguments', which is a node type, is "
"represented as a single AST node and not as a sequence of nodes as with stmt "
"as one might expect."
msgstr ""

#: ../../internals/compiler.rst:94
msgid ""
"All three kinds also have an 'attributes' argument; this is shown by the "
"fact that 'attributes' lacks a '|' before it."
msgstr ""

#: ../../internals/compiler.rst:97
msgid ""
"The statement definitions above generate the following C structure type:"
msgstr ""

#: ../../internals/compiler.rst:123
msgid ""
"Also generated are a series of constructor functions that allocate (in this "
"case) a ``stmt_ty`` struct with the appropriate initialization.  The "
"``kind`` field specifies which component of the union is initialized.  The "
"``FunctionDef()`` constructor function sets 'kind' to ``FunctionDef_kind`` "
"and initializes the *name*, *args*, *body*, and *attributes* fields."
msgstr ""

#: ../../internals/compiler.rst:131
msgid "Memory Management"
msgstr ""

#: ../../internals/compiler.rst:133
msgid ""
"Before discussing the actual implementation of the compiler, a discussion of "
"how memory is handled is in order.  To make memory management simple, an "
"arena is used.  This means that a memory is pooled in a single location for "
"easy allocation and removal.  What this gives us is the removal of explicit "
"memory deallocation.  Because memory allocation for all needed memory in the "
"compiler registers that memory with the arena, a single call to free the "
"arena is all that is needed to completely free all memory used by the "
"compiler."
msgstr ""

#: ../../internals/compiler.rst:141
msgid ""
"In general, unless you are working on the critical core of the compiler, "
"memory management can be completely ignored.  But if you are working at "
"either the very beginning of the compiler or the end, you need to care about "
"how the arena works.  All code relating to the arena is in either :file:"
"`Include/Internal/pycore_pyarena.h` or :file:`Python/pyarena.c`."
msgstr ""

#: ../../internals/compiler.rst:147
msgid ""
"``PyArena_New()`` will create a new arena.  The returned ``PyArena`` "
"structure will store pointers to all memory given to it.  This does the "
"bookkeeping of what memory needs to be freed when the compiler is finished "
"with the memory it used. That freeing is done with ``PyArena_Free()``.  This "
"only needs to be called in strategic areas where the compiler exits."
msgstr ""

#: ../../internals/compiler.rst:153
msgid ""
"As stated above, in general you should not have to worry about memory "
"management when working on the compiler.  The technical details have been "
"designed to be hidden from you for most cases."
msgstr ""

#: ../../internals/compiler.rst:157
msgid ""
"The only exception comes about when managing a PyObject.  Since the rest of "
"Python uses reference counting, there is extra support added to the arena to "
"cleanup each PyObject that was allocated.  These cases are very rare.  "
"However, if you've allocated a PyObject, you must tell the arena about it by "
"calling ``PyArena_AddPyObject()``."
msgstr ""

#: ../../internals/compiler.rst:165
msgid "Source Code to AST"
msgstr ""

#: ../../internals/compiler.rst:167
msgid ""
"The AST is generated from source code using the function "
"``_PyParser_ASTFromString()`` or ``_PyParser_ASTFromFile()`` (from :file:"
"`Parser/peg_api.c`) depending on the input type."
msgstr ""

#: ../../internals/compiler.rst:171
msgid ""
"After some checks, a helper function in :file:`Parser/parser.c` begins "
"applying production rules on the source code it receives; converting source "
"code to tokens and matching these tokens recursively to their corresponding "
"rule.  The rule's corresponding rule function is called on every match.  "
"These rule functions follow the format :samp:`xx_rule`.  Where *xx* is the "
"grammar rule that the function handles and is automatically derived from :"
"file:`Grammar/python.gram` by :file:`Tools/peg_generator/pegen/c_generator."
"py`."
msgstr ""

#: ../../internals/compiler.rst:179
msgid ""
"Each rule function in turn creates an AST node as it goes along.  It does "
"this by allocating all the new nodes it needs, calling the proper AST node "
"creation functions for any required supporting functions and connecting them "
"as needed. This continues until all nonterminal symbols are replaced with "
"terminals.  If an error occurs, the rule functions backtrack and try another "
"rule function.  If there are no more rules, an error is set and the parsing "
"ends."
msgstr ""

#: ../../internals/compiler.rst:186
msgid ""
"The AST node creation helper functions have the name :samp:`_PyAST_{xx}` "
"where *xx* is the AST node that the function creates.  These are defined by "
"the ASDL grammar and contained in :file:`Python/Python-ast.c` (which is "
"generated by :file:`Parser/asdl_c.py` from :file:`Parser/Python.asdl`).  "
"This all leads to a sequence of AST nodes stored in ``asdl_seq`` structs."
msgstr ""

#: ../../internals/compiler.rst:192
msgid ""
"To demonstrate everything explained so far, here's the rule function "
"responsible for a simple named import statement such as ``import sys``.  "
"Note that error-checking and debugging code has been omitted.  Removed parts "
"are represented by ``...``. Furthermore, some comments have been added for "
"explanation.  These comments may not be present in the actual code."
msgstr ""

#: ../../internals/compiler.rst:235
msgid ""
"To improve backtracking performance, some rules (chosen by applying a "
"``(memo)`` flag in the grammar file) are memoized.  Each rule function "
"checks if a memoized version exists and returns that if so, else it "
"continues in the manner stated in the previous paragraphs."
msgstr ""

#: ../../internals/compiler.rst:240
msgid ""
"There are macros for creating and using ``asdl_xx_seq *`` types, where *xx* "
"is a type of the ASDL sequence.  Three main types are defined manually -- "
"``generic``, ``identifier`` and ``int``.  These types are found in :file:"
"`Python/asdl.c` and its corresponding header file :file:`Include/Internal/"
"pycore_asdl.h`.  Functions and macros for creating ``asdl_xx_seq *`` types "
"are as follows:"
msgstr ""

#: ../../internals/compiler.rst:247
msgid "``_Py_asdl_generic_seq_new(Py_ssize_t, PyArena *)``"
msgstr ""

#: ../../internals/compiler.rst:248
msgid "Allocate memory for an ``asdl_generic_seq`` of the specified length"
msgstr ""

#: ../../internals/compiler.rst:249
msgid "``_Py_asdl_identifier_seq_new(Py_ssize_t, PyArena *)``"
msgstr ""

#: ../../internals/compiler.rst:250
msgid "Allocate memory for an ``asdl_identifier_seq`` of the specified length"
msgstr ""

#: ../../internals/compiler.rst:252
msgid "``_Py_asdl_int_seq_new(Py_ssize_t, PyArena *)``"
msgstr ""

#: ../../internals/compiler.rst:252
msgid "Allocate memory for an ``asdl_int_seq`` of the specified length"
msgstr ""

#: ../../internals/compiler.rst:254
msgid ""
"In addition to the three types mentioned above, some ASDL sequence types are "
"automatically generated by :file:`Parser/asdl_c.py` and found in :file:"
"`Include/Internal/pycore_ast.h`.  Macros for using both manually defined and "
"automatically generated ASDL sequence types are as follows:"
msgstr ""

#: ../../internals/compiler.rst:259
msgid "``asdl_seq_GET(asdl_xx_seq *, int)``"
msgstr ""

#: ../../internals/compiler.rst:260
msgid "Get item held at a specific position in an ``asdl_xx_seq``"
msgstr ""

#: ../../internals/compiler.rst:262
msgid "``asdl_seq_SET(asdl_xx_seq *, int, stmt_ty)``"
msgstr ""

#: ../../internals/compiler.rst:262
msgid "Set a specific index in an ``asdl_xx_seq`` to the specified value"
msgstr ""

#: ../../internals/compiler.rst:264
msgid ""
"Untyped counterparts exist for some of the typed macros.  These are useful "
"when a function needs to manipulate a generic ASDL sequence:"
msgstr ""

#: ../../internals/compiler.rst:267
msgid "``asdl_seq_GET_UNTYPED(asdl_seq *, int)``"
msgstr ""

#: ../../internals/compiler.rst:268
msgid "Get item held at a specific position in an ``asdl_seq``"
msgstr ""

#: ../../internals/compiler.rst:269
msgid "``asdl_seq_SET_UNTYPED(asdl_seq *, int, stmt_ty)``"
msgstr ""

#: ../../internals/compiler.rst:270
msgid "Set a specific index in an ``asdl_seq`` to the specified value"
msgstr ""

#: ../../internals/compiler.rst:272
msgid "``asdl_seq_LEN(asdl_seq *)``"
msgstr ""

#: ../../internals/compiler.rst:272
msgid "Return the length of an ``asdl_seq`` or ``asdl_xx_seq``"
msgstr ""

#: ../../internals/compiler.rst:274
msgid ""
"Note that typed macros and functions are recommended over their untyped "
"counterparts.  Typed macros carry out checks in debug mode and aid debugging "
"errors caused by incorrectly casting from ``void *``."
msgstr ""

#: ../../internals/compiler.rst:278
msgid ""
"If you are working with statements, you must also worry about keeping track "
"of what line number generated the statement.  Currently the line number is "
"passed as the last parameter to each ``stmt_ty`` function."
msgstr ""

#: ../../internals/compiler.rst:282
msgid ""
"The new PEG parser generates an AST directly without creating a parse tree. "
"``Python/ast.c`` is now only used to validate the AST for debugging purposes."
msgstr ""

#: ../../internals/compiler.rst:287
msgid ":pep:`617` (PEP 617 -- New PEG parser for CPython)"
msgstr ""

#: ../../internals/compiler.rst:291
msgid "Control Flow Graphs"
msgstr ""

#: ../../internals/compiler.rst:293
msgid ""
"A *control flow graph* (often referenced by its acronym, CFG) is a directed "
"graph that models the flow of a program.  A node of a CFG is not an "
"individual bytecode instruction, but instead represents a sequence of "
"bytecode instructions that always execute sequentially. Each node is called "
"a *basic block* and must always execute from start to finish, with a single "
"entry point at the beginning and a single exit point at the end.  If some "
"bytecode instruction *a* needs to jump to some other bytecode instruction "
"*b*, then *a* must occur at the end of its basic block, and *b* must occur "
"at the start of its basic block."
msgstr ""

#: ../../internals/compiler.rst:304
msgid "As an example, consider the following code snippet:"
msgstr ""

#: ../../internals/compiler.rst:315
msgid ""
"The ``x < 10`` guard is represented by its own basic block that compares "
"``x`` with ``10`` and then ends in a conditional jump based on the result of "
"the comparison.  This conditional jump allows the block to point to both the "
"body of the ``if`` and the body of the ``else``.  The ``if`` basic block "
"contains the ``f1()`` and ``f2()`` calls and points to the ``end()`` basic "
"block. The ``else`` basic block contains the ``g()`` call and similarly "
"points to the ``end()`` block."
msgstr ""

#: ../../internals/compiler.rst:323
msgid ""
"Note that more complex code in the guard, the ``if`` body, or the ``else`` "
"body may be represented by multiple basic blocks. For instance, short-"
"circuiting boolean logic in a guard like ``if x or y:`` will produce one "
"basic block that tests the truth value of ``x`` and then points both (1) to "
"the start of the ``if`` body and (2) to a different basic block that tests "
"the truth value of y."
msgstr ""

#: ../../internals/compiler.rst:330
msgid ""
"CFGs are usually one step away from final code output.  Code is directly "
"generated from the basic blocks (with jump targets adjusted based on the "
"output order) by doing a post-order depth-first search on the CFG following "
"the edges."
msgstr ""

#: ../../internals/compiler.rst:337
msgid "AST to CFG to Bytecode"
msgstr ""

#: ../../internals/compiler.rst:339
msgid ""
"With the AST created, the next step is to create the CFG. The first step is "
"to convert the AST to Python bytecode without having jump targets resolved "
"to specific offsets (this is calculated when the CFG goes to final "
"bytecode). Essentially, this transforms the AST into Python bytecode with "
"control flow represented by the edges of the CFG."
msgstr ""

#: ../../internals/compiler.rst:345
msgid ""
"Conversion is done in two passes.  The first creates the namespace "
"(variables can be classified as local, free/cell for closures, or global).  "
"With that done, the second pass essentially flattens the CFG into a list and "
"calculates jump offsets for final output of bytecode."
msgstr ""

#: ../../internals/compiler.rst:350
msgid ""
"The conversion process is initiated by a call to the function "
"``_PyAST_Compile()`` in :file:`Python/compile.c`.  This function does both "
"the conversion of the AST to a CFG and outputting final bytecode from the "
"CFG. The AST to CFG step is handled mostly by two functions called by "
"``_PyAST_Compile()``; ``_PySymtable_Build()`` and ``compiler_mod()``.  The "
"former is in :file:`Python/symtable.c` while the latter is in :file:`Python/"
"compile.c`."
msgstr ""

#: ../../internals/compiler.rst:357
msgid ""
"``_PySymtable_Build()`` begins by entering the starting code block for the "
"AST (passed-in) and then calling the proper :samp:`symtable_visit_{xx}` "
"function (with *xx* being the AST node type).  Next, the AST tree is walked "
"with the various code blocks that delineate the reach of a local variable as "
"blocks are entered and exited using ``symtable_enter_block()`` and "
"``symtable_exit_block()``, respectively."
msgstr ""

#: ../../internals/compiler.rst:364
msgid ""
"Once the symbol table is created, it is time for CFG creation, whose code is "
"in :file:`Python/compile.c`.  This is handled by several functions that "
"break the task down by various AST node types.  The functions are all named :"
"samp:`compiler_visit_{xx}` where *xx* is the name of the node type (such as "
"``stmt``, ``expr``, etc.).  Each function receives a ``struct compiler *`` "
"and :samp:`{xx}_ty` where *xx* is the AST node type.  Typically these "
"functions consist of a large 'switch' statement, branching based on the kind "
"of node type passed to it.  Simple things are handled inline in the 'switch' "
"statement with more complex transformations farmed out to other functions "
"named :samp:`compiler_{xx}` with *xx* being a descriptive name of what is "
"being handled."
msgstr ""

#: ../../internals/compiler.rst:376
msgid ""
"When transforming an arbitrary AST node, use the ``VISIT()`` macro. The "
"appropriate :samp:`compiler_visit_{xx}` function is called, based on the "
"value passed in for <node type> (so :samp:`VISIT({c}, expr, {node})` calls :"
"samp:`compiler_visit_expr({c}, {node})`).  The ``VISIT_SEQ()`` macro is very "
"similar, but is called on AST node sequences (those values that were created "
"as arguments to a node that used the '*' modifier).  There is also "
"``VISIT_SLICE()`` just for handling slices."
msgstr ""

#: ../../internals/compiler.rst:384
msgid "Emission of bytecode is handled by the following macros:"
msgstr ""

#: ../../internals/compiler.rst:386
msgid "``ADDOP(struct compiler *, int)``"
msgstr ""

#: ../../internals/compiler.rst:387
msgid "add a specified opcode"
msgstr ""

#: ../../internals/compiler.rst:389
msgid "``ADDOP_NOLINE(struct compiler *, int)``"
msgstr ""

#: ../../internals/compiler.rst:389
msgid ""
"like ``ADDOP`` without a line number; used for artificial opcodes without no "
"corresponding token in the source code"
msgstr ""

#: ../../internals/compiler.rst:392
msgid "``ADDOP_IN_SCOPE(struct compiler *, int)``"
msgstr ""

#: ../../internals/compiler.rst:392
msgid ""
"like ``ADDOP``, but also exits current scope; used for adding return value "
"opcodes in lambdas and closures"
msgstr ""

#: ../../internals/compiler.rst:394
msgid "``ADDOP_I(struct compiler *, int, Py_ssize_t)``"
msgstr ""

#: ../../internals/compiler.rst:395
msgid "add an opcode that takes an integer argument"
msgstr ""

#: ../../internals/compiler.rst:402
msgid "``ADDOP_O(struct compiler *, int, PyObject *, TYPE)``"
msgstr ""

#: ../../internals/compiler.rst:397
msgid ""
"add an opcode with the proper argument based on the position of the "
"specified PyObject in PyObject sequence object, but with no handling of "
"mangled names; used for when you need to do named lookups of objects such as "
"globals, consts, or parameters where name mangling is not possible and the "
"scope of the name is known; *TYPE* is the name of PyObject sequence "
"(``names`` or ``varnames``)"
msgstr ""

#: ../../internals/compiler.rst:404
msgid "``ADDOP_N(struct compiler *, int, PyObject *, TYPE)``"
msgstr ""

#: ../../internals/compiler.rst:405
msgid "just like ``ADDOP_O``, but steals a reference to PyObject"
msgstr ""

#: ../../internals/compiler.rst:407
msgid "``ADDOP_NAME(struct compiler *, int, PyObject *, TYPE)``"
msgstr ""

#: ../../internals/compiler.rst:407
msgid ""
"just like ``ADDOP_O``, but name mangling is also handled; used for attribute "
"loading or importing based on name"
msgstr ""

#: ../../internals/compiler.rst:410
msgid "``ADDOP_LOAD_CONST(struct compiler *, PyObject *)``"
msgstr ""

#: ../../internals/compiler.rst:410
msgid ""
"add the ``LOAD_CONST`` opcode with the proper argument based on the position "
"of the specified PyObject in the consts table."
msgstr ""

#: ../../internals/compiler.rst:412
msgid "``ADDOP_LOAD_CONST_NEW(struct compiler *, PyObject *)``"
msgstr ""

#: ../../internals/compiler.rst:413
msgid "just like ``ADDOP_LOAD_CONST_NEW``, but steals a reference to PyObject"
msgstr ""

#: ../../internals/compiler.rst:414
msgid "``ADDOP_JUMP(struct compiler *, int, basicblock *)``"
msgstr ""

#: ../../internals/compiler.rst:415
msgid "create a jump to a basic block"
msgstr ""

#: ../../internals/compiler.rst:417
msgid "``ADDOP_JUMP_NOLINE(struct compiler *, int, basicblock *)``"
msgstr ""

#: ../../internals/compiler.rst:417
msgid ""
"like ``ADDOP_JUMP`` without a line number; used for artificial jumps without "
"no corresponding token in the source code."
msgstr ""

#: ../../internals/compiler.rst:421
msgid "``ADDOP_JUMP_COMPARE(struct compiler *, cmpop_ty)``"
msgstr ""

#: ../../internals/compiler.rst:420
msgid ""
"depending on the second argument, add an ``ADDOP_I`` with either an "
"``IS_OP``, ``CONTAINS_OP``, or ``COMPARE_OP`` opcode."
msgstr ""

#: ../../internals/compiler.rst:423
msgid ""
"Several helper functions that will emit bytecode and are named :samp:"
"`compiler_{xx}()` where *xx* is what the function helps with (``list``, "
"``boolop``, etc.).  A rather useful one is ``compiler_nameop()``. This "
"function looks up the scope of a variable and, based on the expression "
"context, emits the proper opcode to load, store, or delete the variable."
msgstr ""

#: ../../internals/compiler.rst:430
msgid ""
"As for handling the line number on which a statement is defined, this is "
"handled by ``compiler_visit_stmt()`` and thus is not a worry."
msgstr ""

#: ../../internals/compiler.rst:433
msgid ""
"In addition to emitting bytecode based on the AST node, handling the "
"creation of basic blocks must be done.  Below are the macros and functions "
"used for managing basic blocks:"
msgstr ""

#: ../../internals/compiler.rst:438
msgid "``NEXT_BLOCK(struct compiler *)``"
msgstr ""

#: ../../internals/compiler.rst:438
msgid "create an implicit jump from the current block to the new block"
msgstr ""

#: ../../internals/compiler.rst:440
msgid "``compiler_new_block(struct compiler *)``"
msgstr ""

#: ../../internals/compiler.rst:441
msgid "create a block but don't use it (used for generating jumps)"
msgstr ""

#: ../../internals/compiler.rst:443
msgid "``compiler_use_next_block(struct compiler *, basicblock *block)``"
msgstr ""

#: ../../internals/compiler.rst:443
msgid "set a previously created block as a current block"
msgstr ""

#: ../../internals/compiler.rst:445
msgid ""
"Once the CFG is created, it must be flattened and then final emission of "
"bytecode occurs.  Flattening is handled using a post-order depth-first "
"search.  Once flattened, jump offsets are backpatched based on the "
"flattening and then a ``PyCodeObject`` is created.  All of this is handled "
"by calling ``assemble()``."
msgstr ""

#: ../../internals/compiler.rst:453
msgid "Introducing New Bytecode"
msgstr ""

#: ../../internals/compiler.rst:455
msgid ""
"Sometimes a new feature requires a new opcode.  But adding new bytecode is "
"not as simple as just suddenly introducing new bytecode in the AST -> "
"bytecode step of the compiler.  Several pieces of code throughout Python "
"depend on having correct information about what bytecode exists."
msgstr ""

#: ../../internals/compiler.rst:460
msgid ""
"First, you must choose a name and a unique identifier number.  The official "
"list of bytecode can be found in :file:`Lib/opcode.py`.  If the opcode is to "
"take an argument, it must be given a unique number greater than that "
"assigned to ``HAVE_ARGUMENT`` (as found in :file:`Lib/opcode.py`)."
msgstr ""

#: ../../internals/compiler.rst:465
msgid ""
"Once the name/number pair has been chosen and entered in :file:`Lib/opcode."
"py`, you must also enter it into :file:`Doc/library/dis.rst`, and "
"regenerate :file:`Include/opcode.h` and :file:`Python/opcode_targets.h` by "
"running ``make regen-opcode regen-opcode-targets``."
msgstr ""

#: ../../internals/compiler.rst:470
msgid ""
"With a new bytecode you must also change what is called the magic number "
"for .pyc files.  The variable ``MAGIC_NUMBER`` in :file:`Lib/importlib/"
"_bootstrap_external.py` contains the number. Changing this number will lead "
"to all .pyc files with the old ``MAGIC_NUMBER`` to be recompiled by the "
"interpreter on import.  Whenever ``MAGIC_NUMBER`` is changed, the ranges in "
"the ``magic_values`` array in :file:`PC/launcher.c` must also be updated.  "
"Changes to :file:`Lib/importlib/_bootstrap_external.py` will take effect "
"only after running ``make regen-importlib``. Running this command before "
"adding the new bytecode target to :file:`Python/ceval.c` will result in an "
"error. You should only run ``make regen-importlib`` after the new bytecode "
"target has been added."
msgstr ""

#: ../../internals/compiler.rst:482
msgid ""
"On Windows, running the ``./build.bat`` script will automatically regenerate "
"the required files without requiring additional arguments."
msgstr ""

#: ../../internals/compiler.rst:485
msgid ""
"Finally, you need to introduce the use of the new bytecode.  Altering :file:"
"`Python/compile.c` and :file:`Python/ceval.c` will be the primary places to "
"change. You must add the case for a new opcode into the 'switch' statement "
"in the ``stack_effect()`` function in :file:`Python/compile.c`. If the new "
"opcode has a jump target, you will need to update macros and 'switch' "
"statements in :file:`Python/peephole.c`.  If it affects a control flow or "
"the block stack, you may have to update the ``frame_setlineno()`` function "
"in :file:`Objects/frameobject.c`.  :file:`Lib/dis.py` may need an update if "
"the new opcode interprets its argument in a special way (like "
"``FORMAT_VALUE`` or ``MAKE_FUNCTION``)."
msgstr ""

#: ../../internals/compiler.rst:496
msgid ""
"If you make a change here that can affect the output of bytecode that is "
"already in existence and you do not change the magic number constantly, make "
"sure to delete your old .py(c|o) files!  Even though you will end up "
"changing the magic number if you change the bytecode, while you are "
"debugging your work you will be changing the bytecode output without "
"constantly bumping up the magic number.  This means you end up with stale ."
"pyc files that will not be recreated. Running ``find . -name '*.py[co]' -"
"exec rm -f '{}' +`` should delete all .pyc files you have, forcing new ones "
"to be created and thus allow you test out your new bytecode properly.  Run "
"``make regen-importlib`` for updating the bytecode of frozen importlib "
"files.  You have to run ``make`` again after this for recompiling generated "
"C files."
msgstr ""

#: ../../internals/compiler.rst:511
msgid "Code Objects"
msgstr ""

#: ../../internals/compiler.rst:513
msgid ""
"The result of ``PyAST_CompileObject()`` is a ``PyCodeObject`` which is "
"defined in :file:`Include/code.h`.  And with that you now have executable "
"Python bytecode!"
msgstr ""

#: ../../internals/compiler.rst:516
msgid ""
"The code objects (byte code) are executed in :file:`Python/ceval.c`.  This "
"file will also need a new case statement for the new opcode in the big "
"switch statement in ``_PyEval_EvalFrameDefault()``."
msgstr ""

#: ../../internals/compiler.rst:522
msgid "Important Files"
msgstr ""

#: ../../internals/compiler.rst:524
msgid "Parser/"
msgstr ""

#: ../../internals/compiler.rst:527
msgid "Python.asdl"
msgstr ""

#: ../../internals/compiler.rst:527
msgid "ASDL syntax file"
msgstr ""

#: ../../internals/compiler.rst:531
msgid "asdl.py"
msgstr ""

#: ../../internals/compiler.rst:530
msgid ""
"Parser for ASDL definition files. Reads in an ASDL description and parses it "
"into an AST that describes it."
msgstr ""

#: ../../internals/compiler.rst:535
msgid "asdl_c.py"
msgstr ""

#: ../../internals/compiler.rst:534
msgid ""
"\"Generate C code from an ASDL description.\"  Generates :file:`Python/"
"Python-ast.c` and :file:`Include/Internal/pycore_ast.h`."
msgstr ""

#: ../../internals/compiler.rst:542
msgid "parser.c"
msgstr ""

#: ../../internals/compiler.rst:538
msgid ""
"The new PEG parser introduced in Python 3.9. Generated by :file:`Tools/"
"peg_generator/pegen/c_generator.py` from the grammar :file:`Grammar/python."
"gram`.  Creates the AST from source code.  Rule functions for their "
"corresponding production rules are found here."
msgstr ""

#: ../../internals/compiler.rst:546
msgid "peg_api.c"
msgstr ""

#: ../../internals/compiler.rst:545
msgid ""
"Contains high-level functions which are used by the interpreter to create an "
"AST from source code ."
msgstr ""

#: ../../internals/compiler.rst:552
msgid "pegen.c"
msgstr ""

#: ../../internals/compiler.rst:549
msgid ""
"Contains helper functions which are used by functions in :file:`Parser/"
"parser.c` to construct the AST.  Also contains helper functions which help "
"raise better error messages when parsing source code."
msgstr ""

#: ../../internals/compiler.rst:556
msgid "pegen.h"
msgstr ""

#: ../../internals/compiler.rst:555
msgid ""
"Header file for the corresponding :file:`Parser/pegen.c`. Also contains "
"definitions of the ``Parser`` and ``Token`` structs."
msgstr ""

#: ../../internals/compiler.rst:558
msgid "Python/"
msgstr ""

#: ../../internals/compiler.rst:566
msgid "Python-ast.c"
msgstr ""

#: ../../internals/compiler.rst:561
msgid ""
"Creates C structs corresponding to the ASDL types.  Also contains code for "
"marshalling AST nodes (core ASDL types have marshalling code in :file:`asdl."
"c`).  \"File automatically generated by :file:`Parser/asdl_c.py`\".  This "
"file must be committed separately after every grammar change is committed "
"since the ``__version__`` value is set to the latest grammar change revision "
"number."
msgstr ""

#: ../../internals/compiler.rst:571
msgid "asdl.c"
msgstr ""

#: ../../internals/compiler.rst:569
msgid ""
"Contains code to handle the ASDL sequence type.  Also has code to handle "
"marshalling the core ASDL types, such as number and identifier.  Used by :"
"file:`Python-ast.c` for marshalling AST nodes."
msgstr ""

#: ../../internals/compiler.rst:574
msgid "ast.c"
msgstr ""

#: ../../internals/compiler.rst:574
msgid "Used for validating the AST."
msgstr ""

#: ../../internals/compiler.rst:577
msgid "ast_opt.c"
msgstr ""

#: ../../internals/compiler.rst:577
msgid "Optimizes the AST."
msgstr ""

#: ../../internals/compiler.rst:581
msgid "ast_unparse.c"
msgstr ""

#: ../../internals/compiler.rst:580
msgid ""
"Converts the AST expression node back into a string (for string annotations)."
msgstr ""

#: ../../internals/compiler.rst:584
msgid "ceval.c"
msgstr ""

#: ../../internals/compiler.rst:584
msgid "Executes byte code (aka, eval loop)."
msgstr ""

#: ../../internals/compiler.rst:587
msgid "compile.c"
msgstr ""

#: ../../internals/compiler.rst:587
msgid "Emits bytecode based on the AST."
msgstr ""

#: ../../internals/compiler.rst:590
msgid "symtable.c"
msgstr ""

#: ../../internals/compiler.rst:590
msgid "Generates a symbol table from AST."
msgstr ""

#: ../../internals/compiler.rst:593
msgid "peephole.c"
msgstr ""

#: ../../internals/compiler.rst:593
msgid "Optimizes the bytecode."
msgstr ""

#: ../../internals/compiler.rst:596
msgid "pyarena.c"
msgstr ""

#: ../../internals/compiler.rst:596
msgid "Implementation of the arena memory manager."
msgstr ""

#: ../../internals/compiler.rst:599
msgid "wordcode_helpers.h"
msgstr ""

#: ../../internals/compiler.rst:599
msgid "Helpers for generating bytecode."
msgstr ""

#: ../../internals/compiler.rst:602
msgid "opcode_targets.h"
msgstr ""

#: ../../internals/compiler.rst:602 ../../internals/compiler.rst:611
msgid "One of the files that must be modified if :file:`Lib/opcode.py` is."
msgstr ""

#: ../../internals/compiler.rst:604
msgid "Include/"
msgstr ""

#: ../../internals/compiler.rst:608
msgid "code.h"
msgstr ""

#: ../../internals/compiler.rst:607
msgid ""
"Header file for :file:`Objects/codeobject.c`; contains definition of "
"``PyCodeObject``."
msgstr ""

#: ../../internals/compiler.rst:611
msgid "opcode.h"
msgstr ""

#: ../../internals/compiler.rst:613
msgid "Internal/"
msgstr ""

#: ../../internals/compiler.rst:618 ../../internals/compiler.rst:624
msgid "pycore_ast.h"
msgstr ""

#: ../../internals/compiler.rst:616
msgid ""
"Contains the actual definitions of the C structs as generated by :file:"
"`Python/Python-ast.c`. \"Automatically generated by :file:`Parser/asdl_c."
"py`\"."
msgstr ""

#: ../../internals/compiler.rst:621
msgid "pycore_asdl.h"
msgstr ""

#: ../../internals/compiler.rst:621
msgid "Header for the corresponding :file:`Python/ast.c`"
msgstr ""

#: ../../internals/compiler.rst:624
msgid "Declares ``_PyAST_Validate()`` external (from :file:`Python/ast.c`)."
msgstr ""

#: ../../internals/compiler.rst:628
msgid "pycore_symtable.h"
msgstr ""

#: ../../internals/compiler.rst:627
msgid ""
"Header for :file:`Python/symtable.c`.  ``struct symtable`` and "
"``PySTEntryObject`` are defined here."
msgstr ""

#: ../../internals/compiler.rst:631
msgid "pycore_parser.h"
msgstr ""

#: ../../internals/compiler.rst:631
msgid "Header for the corresponding :file:`Parser/peg_api.c`."
msgstr ""

#: ../../internals/compiler.rst:635
msgid "pycore_pyarena.h"
msgstr ""

#: ../../internals/compiler.rst:634
msgid "Header file for the corresponding :file:`Python/pyarena.c`."
msgstr ""

#: ../../internals/compiler.rst:637
msgid "Objects/"
msgstr ""

#: ../../internals/compiler.rst:641
msgid "codeobject.c"
msgstr ""

#: ../../internals/compiler.rst:640
msgid ""
"Contains PyCodeObject-related code (originally in :file:`Python/compile.c`)."
msgstr ""

#: ../../internals/compiler.rst:645
msgid "frameobject.c"
msgstr ""

#: ../../internals/compiler.rst:644
msgid ""
"Contains the ``frame_setlineno()`` function which should determine whether "
"it is allowed to make a jump between two points in a bytecode."
msgstr ""

#: ../../internals/compiler.rst:647
msgid "Lib/"
msgstr ""

#: ../../internals/compiler.rst:651
msgid "opcode.py"
msgstr ""

#: ../../internals/compiler.rst:650
msgid ""
"Master list of bytecode; if this file is modified you must modify several "
"other files accordingly (see \"`Introducing New Bytecode`_\")"
msgstr ""

#: ../../internals/compiler.rst:656
msgid "importlib/_bootstrap_external.py"
msgstr ""

#: ../../internals/compiler.rst:654
msgid ""
"Home of the magic number (named ``MAGIC_NUMBER``) for bytecode versioning."
msgstr ""

#: ../../internals/compiler.rst:659
msgid "Known Compiler-related Experiments"
msgstr ""

#: ../../internals/compiler.rst:661
msgid ""
"This section lists known experiments involving the compiler (including "
"bytecode)."
msgstr ""

#: ../../internals/compiler.rst:664
msgid ""
"Skip Montanaro presented a paper at a Python workshop on a peephole "
"optimizer [#skip-peephole]_."
msgstr ""

#: ../../internals/compiler.rst:667
msgid ""
"Michael Hudson has a non-active SourceForge project named Bytecodehacks "
"[#Bytecodehacks]_ that provides functionality for playing with bytecode "
"directly."
msgstr ""

#: ../../internals/compiler.rst:671
msgid ""
"An opcode to combine the functionality of ``LOAD_ATTR``/``CALL_FUNCTION`` "
"was created named ``CALL_ATTR`` [#CALL_ATTR]_.  Currently only works for "
"classic classes and for new-style classes rough benchmarking showed an "
"actual slowdown thanks to having to support both classic and new-style "
"classes."
msgstr ""

#: ../../internals/compiler.rst:679
msgid "References"
msgstr ""

#: ../../internals/compiler.rst:681
msgid ""
"Daniel C. Wang, Andrew W. Appel, Jeff L. Korn, and Chris S. Serra.  `The "
"Zephyr Abstract Syntax Description Language.`_ In Proceedings of the "
"Conference on Domain-Specific Languages, pp. 213--227, 1997."
msgstr ""

#: ../../internals/compiler.rst:689
msgid ""
"Skip Montanaro's Peephole Optimizer Paper (https://legacy.python.org/"
"workshops/1998-11/proceedings/papers/montanaro/montanaro.html)"
msgstr ""

#: ../../internals/compiler.rst:692
msgid ""
"Bytecodehacks Project (https://bytecodehacks.sourceforge.net/bch-docs/bch/"
"index.html)"
msgstr ""

#: ../../internals/compiler.rst:695
msgid "CALL_ATTR opcode (https://bugs.python.org/issue709744)"
msgstr ""
