# Brazilian Portuguese translation for internals/parser.po
# Copyright (C) 2011-2022, Python Software Foundation
# This file is distributed under the same license as the Python Developer's
# Guide package.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Developer's Guide\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-17 23:29-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../internals/parser.rst:5
msgid "Guide to the Parser"
msgstr ""

#: ../../internals/parser.rst
msgid "Author"
msgstr ""

#: ../../internals/parser.rst:7
msgid "Pablo Galindo Salgado"
msgstr "Pablo Galindo Salgado"

#: ../../internals/parser.rst:12
msgid "Abstract"
msgstr ""

#: ../../internals/parser.rst:14
msgid ""
"The Parser in CPython is currently a `PEG (Parser Expression Grammar) "
"<https://en.wikipedia.org/wiki/Parsing_expression_grammar>`_ parser.  The "
"first version of the parser used to be an `LL(1) <https://en.wikipedia.org/"
"wiki/LL_parser>`_ based parser that was one of the oldest parts of CPython "
"implemented before it was replaced by :pep:`617`. In particular, both the "
"current parser and the old LL(1) parser are the output of a `parser "
"generator <https://en.wikipedia.org/wiki/Compiler-compiler>`_. This means "
"that the way the parser is written is by feeding a description of the "
"Grammar of the Python language to a special program (the parser generator) "
"which outputs the parser. The way the Python language is changed is "
"therefore by modifying the grammar file and developers rarely need to "
"interact with the parser generator itself other than use it to generate the "
"parser."
msgstr ""

#: ../../internals/parser.rst:28
msgid "How PEG Parsers Work"
msgstr ""

#: ../../internals/parser.rst:32
msgid ""
"A PEG (Parsing Expression Grammar) grammar (like the current one) differs "
"from a context-free grammar in that the way it is written more closely "
"reflects how the parser will operate when parsing it. The fundamental "
"technical difference is that the choice operator is ordered. This means that "
"when writing::"
msgstr ""

#: ../../internals/parser.rst:39
msgid ""
"a context-free-grammar parser (like an LL(1) parser) will generate "
"constructions that given an input string will *deduce* which alternative "
"(``A``, ``B`` or ``C``) must be expanded, while a PEG parser will check if "
"the first alternative succeeds and only if it fails, will it continue with "
"the second or the third one in the order in which they are written. This "
"makes the choice operator not commutative."
msgstr ""

#: ../../internals/parser.rst:45
msgid ""
"Unlike LL(1) parsers, PEG-based parsers cannot be ambiguous: if a string "
"parses, it has exactly one valid parse tree. This means that a PEG-based "
"parser cannot suffer from the ambiguity problems that can arise with LL(1) "
"parsers and with context-free grammars in general."
msgstr ""

#: ../../internals/parser.rst:50
msgid ""
"PEG parsers are usually constructed as a recursive descent parser in which "
"every rule in the grammar corresponds to a function in the program "
"implementing the parser and the parsing expression (the \"expansion\" or "
"\"definition\" of the rule) represents the \"code\" in said function. Each "
"parsing function conceptually takes an input string as its argument, and "
"yields one of the following results:"
msgstr ""

#: ../../internals/parser.rst:56
msgid ""
"A \"success\" result. This result indicates that the expression can be "
"parsed by that rule and the function may optionally move forward or consume "
"one or more characters of the input string supplied to it."
msgstr ""

#: ../../internals/parser.rst:59
msgid "A \"failure\" result, in which case no input is consumed."
msgstr ""

#: ../../internals/parser.rst:61
msgid ""
"Notice that \"failure\" results do not imply that the program is incorrect, "
"nor do they necessarily mean that the parsing has failed. Since the choice "
"operator is ordered, a failure very often merely indicates \"try the "
"following option\".  A direct implementation of a PEG parser as a recursive "
"descent parser will present exponential time performance in the worst case, "
"because PEG parsers have infinite lookahead (this means that they can "
"consider an arbitrary number of tokens before deciding for a rule).  "
"Usually, PEG parsers avoid this exponential time complexity with a technique "
"called \"packrat parsing\" [1]_ which not only loads the entire program in "
"memory before parsing it but also allows the parser to backtrack "
"arbitrarily. This is made efficient by memoizing the rules already matched "
"for each position. The cost of the memoization cache is that the parser will "
"naturally use more memory than a simple LL(1) parser, which normally are "
"table-based."
msgstr ""

#: ../../internals/parser.rst:77
msgid "Key ideas"
msgstr ""

#: ../../internals/parser.rst:80
msgid ""
"Don't try to reason about a PEG grammar in the same way you would to with an "
"EBNF or context free grammar. PEG is optimized to describe **how** input "
"strings will be parsed, while context-free grammars are optimized to "
"generate strings of the language they describe (in EBNF, to know if a given "
"string is in the language, you need to do work to find out as it is not "
"immediately obvious from the grammar)."
msgstr ""

#: ../../internals/parser.rst:86
msgid "Alternatives are ordered ( ``A | B`` is not the same as ``B | A`` )."
msgstr ""

#: ../../internals/parser.rst:87
msgid ""
"If a rule returns a failure, it doesn't mean that the parsing has failed, it "
"just means \"try something else\"."
msgstr ""

#: ../../internals/parser.rst:89
msgid ""
"By default PEG parsers run in exponential time, which can be optimized to "
"linear by using memoization."
msgstr ""

#: ../../internals/parser.rst:91
msgid ""
"If parsing fails completely (no rule succeeds in parsing all the input "
"text), the PEG parser doesn't have a concept of \"where the :exc:"
"`SyntaxError` is\"."
msgstr ""

#: ../../internals/parser.rst:98
msgid "Consequences of the ordered choice operator"
msgstr ""

#: ../../internals/parser.rst:100
msgid ""
"Although PEG may look like EBNF, its meaning is quite different. The fact "
"that in PEG parsers alternatives are ordered (which is at the core of how "
"PEG parsers work) has deep consequences, other than removing ambiguity."
msgstr ""

#: ../../internals/parser.rst:104
msgid ""
"If a rule has two alternatives and the first of them succeeds, the second "
"one is **not** attempted even if the caller rule fails to parse the rest of "
"the input. Thus the parser is said to be \"eager\". To illustrate this, "
"consider the following two rules (in these examples, a token is an "
"individual character): ::"
msgstr ""

#: ../../internals/parser.rst:112
msgid ""
"In a regular EBNF grammar, both rules specify the language ``{aa, aaa}`` but "
"in PEG, one of these two rules accepts the string ``aaa`` but not the string "
"``aa``. The other does the opposite -- it accepts the string ``aa`` but not "
"the string ``aaa``. The rule ``('a'|'aa')'a'`` does not accept ``aaa`` "
"because ``'a'|'aa'`` consumes the first ``a``, letting the final ``a`` in "
"the rule consume the second, and leaving out the third ``a``. As the rule "
"has succeeded, no attempt is ever made to go back and let ``'a'|'aa'`` try "
"the second alternative. The expression ``('aa'|'a')'a'`` does not accept "
"``aa`` because ``'aa'|'a'`` accepts all of ``aa``, leaving nothing for the "
"final ``a``. Again, the second alternative of ``'aa'|'a'`` is not tried."
msgstr ""

#: ../../internals/parser.rst:126
msgid ""
"The effects of ordered choice, such as the ones illustrated above, may be "
"hidden by many levels of rules."
msgstr ""

#: ../../internals/parser.rst:128
msgid ""
"For this reason, writing rules where an alternative is contained in the next "
"one is in almost all cases a mistake, for example: ::"
msgstr ""

#: ../../internals/parser.rst:135
msgid ""
"In this example, the second alternative will never be tried because the "
"first one will succeed first (even if the input string has an ``'else' "
"block`` that follows). To correctly write this rule you can simply alter the "
"order: ::"
msgstr ""

#: ../../internals/parser.rst:143
msgid ""
"In this case, if the input string doesn't have an ``'else' block``, the "
"first alternative will fail and the second will be attempted without said "
"part."
msgstr ""

#: ../../internals/parser.rst:147
msgid "Syntax"
msgstr ""

#: ../../internals/parser.rst:149
msgid "The grammar consists of a sequence of rules of the form: ::"
msgstr ""

#: ../../internals/parser.rst:153
msgid ""
"Optionally, a type can be included right after the rule name, which "
"specifies the return type of the C or Python function corresponding to the "
"rule: ::"
msgstr ""

#: ../../internals/parser.rst:159
msgid ""
"If the return type is omitted, then a ``void *`` is returned in C and an "
"``Any`` in Python."
msgstr ""

#: ../../internals/parser.rst:163
msgid "Grammar Expressions"
msgstr ""

#: ../../internals/parser.rst:166
msgid "``# comment``"
msgstr ""

#: ../../internals/parser.rst:168
msgid "Python-style comments."
msgstr ""

#: ../../internals/parser.rst:171
msgid "``e1 e2``"
msgstr ""

#: ../../internals/parser.rst:173
msgid "Match ``e1``, then match ``e2``."
msgstr ""

#: ../../internals/parser.rst:180
msgid "``e1 | e2``"
msgstr ""

#: ../../internals/parser.rst:182
msgid "Match ``e1`` or ``e2``."
msgstr ""

#: ../../internals/parser.rst:184
msgid ""
"The first alternative can also appear on the line after the rule name for "
"formatting purposes. In that case, a \\| must be used before the first "
"alternative, like so:"
msgstr ""

#: ../../internals/parser.rst:195
msgid "``( e )``"
msgstr ""

#: ../../internals/parser.rst:197
msgid "Match ``e``."
msgstr ""

#: ../../internals/parser.rst:203
msgid ""
"A slightly more complex and useful example includes using the grouping "
"operator together with the repeat operators:"
msgstr ""

#: ../../internals/parser.rst:211
msgid "``[ e ] or e?``"
msgstr ""

#: ../../internals/parser.rst:213
msgid "Optionally match ``e``."
msgstr ""

#: ../../internals/parser.rst:219
msgid ""
"A more useful example includes defining that a trailing comma is optional:"
msgstr ""

#: ../../internals/parser.rst:227
msgid "``e*``"
msgstr ""

#: ../../internals/parser.rst:229
msgid "Match zero or more occurrences of ``e``."
msgstr ""

#: ../../internals/parser.rst:236
msgid "``e+``"
msgstr ""

#: ../../internals/parser.rst:238
msgid "Match one or more occurrences of ``e``."
msgstr ""

#: ../../internals/parser.rst:245
msgid "``s.e+``"
msgstr ""

#: ../../internals/parser.rst:247
msgid ""
"Match one or more occurrences of ``e``, separated by ``s``. The generated "
"parse tree does not include the separator. This is otherwise identical to "
"``(e (s e)*)``."
msgstr ""

#: ../../internals/parser.rst:256
msgid "``&e``"
msgstr ""

#: ../../internals/parser.rst:260
msgid "Succeed if ``e`` can be parsed, without consuming any input."
msgstr ""

#: ../../internals/parser.rst:263
msgid "``!e``"
msgstr ""

#: ../../internals/parser.rst:267
msgid "Fail if ``e`` can be parsed, without consuming any input."
msgstr ""

#: ../../internals/parser.rst:269
msgid ""
"An example taken from the Python grammar specifies that a primary consists "
"of an atom, which is not followed by a ``.`` or a ``(`` or a ``[``:"
msgstr ""

#: ../../internals/parser.rst:278
msgid "``~``"
msgstr ""

#: ../../internals/parser.rst:280
msgid ""
"Commit to the current alternative, even if it fails to parse (this is called "
"the \"cut\")."
msgstr ""

#: ../../internals/parser.rst:287
msgid ""
"In this example, if a left parenthesis is parsed, then the other alternative "
"won’t be considered, even if some_rule or ``)`` fail to be parsed."
msgstr ""

#: ../../internals/parser.rst:292
msgid "Left recursion"
msgstr ""

#: ../../internals/parser.rst:294
msgid ""
"PEG parsers normally do not support left recursion but CPython's parser "
"generator implements a technique similar to the one described in Medeiros et "
"al. [2]_ but using the memoization cache instead of static variables. This "
"approach is closer to the one described in Warth et al. [3]_. This allows us "
"to write not only simple left-recursive rules but also more complicated "
"rules that involve indirect left-recursion like::"
msgstr ""

#: ../../internals/parser.rst:305
msgid "and \"hidden left-recursion\" like::"
msgstr ""

#: ../../internals/parser.rst:310
msgid "Variables in the Grammar"
msgstr ""

#: ../../internals/parser.rst:312
msgid ""
"A sub-expression can be named by preceding it with an identifier and an "
"``=`` sign. The name can then be used in the action (see below), like "
"this: ::"
msgstr ""

#: ../../internals/parser.rst:318
msgid "Grammar actions"
msgstr ""

#: ../../internals/parser.rst:322
msgid ""
"To avoid the intermediate steps that obscure the relationship between the "
"grammar and the AST generation the PEG parser allows directly generating AST "
"nodes for a rule via grammar actions. Grammar actions are language-specific "
"expressions that are evaluated when a grammar rule is successfully parsed. "
"These expressions can be written in Python or C depending on the desired "
"output of the parser generator. This means that if one would want to "
"generate a parser in Python and another in C, two grammar files should be "
"written, each one with a different set of actions, keeping everything else "
"apart from said actions identical in both files. As an example of a grammar "
"with Python actions, the piece of the parser generator that parses grammar "
"files is bootstrapped from a meta-grammar file with Python actions that "
"generate the grammar tree as a result of the parsing."
msgstr ""

#: ../../internals/parser.rst:335
msgid ""
"In the specific case of the PEG grammar for Python, having actions allows "
"directly describing how the AST is composed in the grammar itself, making it "
"more clear and maintainable. This AST generation process is supported by the "
"use of some helper functions that factor out common AST object manipulations "
"and some other required operations that are not directly related to the "
"grammar."
msgstr ""

#: ../../internals/parser.rst:341
msgid ""
"To indicate these actions each alternative can be followed by the action "
"code inside curly-braces, which specifies the return value of the "
"alternative::"
msgstr ""

#: ../../internals/parser.rst:348
msgid "If the action is omitted, a default action is generated:"
msgstr ""

#: ../../internals/parser.rst:350
msgid "If there's a single name in the rule, it gets returned."
msgstr ""

#: ../../internals/parser.rst:352
msgid ""
"If there is more than one name in the rule, a collection with all parsed "
"expressions gets returned (the type of the collection will be different in C "
"and Python)."
msgstr ""

#: ../../internals/parser.rst:356
msgid ""
"This default behaviour is primarily made for very simple situations and for "
"debugging purposes."
msgstr ""

#: ../../internals/parser.rst:361
msgid ""
"It's important that the actions don't mutate any AST nodes that are passed "
"into them via variables referring to other rules. The reason for mutation "
"being not allowed is that the AST nodes are cached by memoization and could "
"potentially be reused in a different context, where the mutation would be "
"invalid. If an action needs to change an AST node, it should instead make a "
"new copy of the node and change that."
msgstr ""

#: ../../internals/parser.rst:368
msgid ""
"The full meta-grammar for the grammars supported by the PEG generator is:"
msgstr ""

#: ../../internals/parser.rst:459
msgid ""
"As an illustrative example this simple grammar file allows directly "
"generating a full parser that can parse simple arithmetic expressions and "
"that returns a valid C-based Python AST:"
msgstr ""

#: ../../internals/parser.rst:486
msgid ""
"Here ``EXTRA`` is a macro that expands to ``start_lineno, start_col_offset, "
"end_lineno, end_col_offset, p->arena``, those being variables automatically "
"injected by the parser; ``p`` points to an object that holds on to all state "
"for the parser."
msgstr ""

#: ../../internals/parser.rst:491
msgid "A similar grammar written to target Python AST objects:"
msgstr ""

#: ../../internals/parser.rst:518
msgid "Pegen"
msgstr ""

#: ../../internals/parser.rst:520
msgid ""
"Pegen is the parser generator used in CPython to produce the final PEG "
"parser used by the interpreter. It is the program that can be used to read "
"the python grammar located in :cpy-file:`Grammar/python.gram` and produce "
"the final C parser. It contains the following pieces:"
msgstr ""

#: ../../internals/parser.rst:524
msgid ""
"A parser generator that can read a grammar file and produce a PEG parser "
"written in Python or C that can parse said grammar. The generator is located "
"at :cpy-file:`Tools/peg_generator/pegen`."
msgstr ""

#: ../../internals/parser.rst:526
msgid ""
"A PEG meta-grammar that automatically generates a Python parser that is used "
"for the parser generator itself (this means that there are no manually-"
"written parsers). The meta-grammar is located at :cpy-file:`Tools/"
"peg_generator/pegen/metagrammar.gram`."
msgstr ""

#: ../../internals/parser.rst:529
msgid ""
"A generated parser (using the parser generator) that can directly produce C "
"and Python AST objects."
msgstr ""

#: ../../internals/parser.rst:531
msgid ""
"The source code for Pegen lives at :cpy-file:`Tools/peg_generator/pegen` but "
"normally all typical commands to interact with the parser generator are "
"executed from the main makefile."
msgstr ""

#: ../../internals/parser.rst:535
msgid "How to regenerate the parser"
msgstr ""

#: ../../internals/parser.rst:537
msgid ""
"Once you have made the changes to the grammar files, to regenerate the ``C`` "
"parser (the one used by the interpreter) just execute: ::"
msgstr ""

#: ../../internals/parser.rst:542
msgid ""
"using the :cpy-file:`!Makefile` in the main directory.  If you are on "
"Windows you can use the Visual Studio project files to regenerate the parser "
"or to execute: ::"
msgstr ""

#: ../../internals/parser.rst:547
msgid "The generated parser file is located at :cpy-file:`Parser/parser.c`."
msgstr ""

#: ../../internals/parser.rst:550
msgid "How to regenerate the meta-parser"
msgstr ""

#: ../../internals/parser.rst:552
msgid ""
"The meta-grammar (the grammar that describes the grammar for the grammar "
"files themselves) is located at :cpy-file:`Tools/peg_generator/pegen/"
"metagrammar.gram`. Although it is very unlikely that you will ever need to "
"modify it, if you make any modifications to this file (in order to implement "
"new Pegen features) you will need to regenerate the meta-parser (the parser "
"that parses the grammar files). To do so just execute: ::"
msgstr ""

#: ../../internals/parser.rst:560
msgid ""
"If you are on Windows you can use the Visual Studio project files to "
"regenerate the parser or to execute: ::"
msgstr ""

#: ../../internals/parser.rst:567
msgid "Grammatical elements and rules"
msgstr ""

#: ../../internals/parser.rst:569
msgid "Pegen has some special grammatical elements and rules:"
msgstr ""

#: ../../internals/parser.rst:571
msgid "Strings with single quotes (') (e.g. ``'class'``) denote KEYWORDS."
msgstr ""

#: ../../internals/parser.rst:572
msgid ""
"Strings with double quotes (\") (e.g. ``\"match\"``) denote SOFT KEYWORDS."
msgstr ""

#: ../../internals/parser.rst:573
msgid ""
"Upper case names (e.g. ``NAME``) denote tokens in the :cpy-file:`Grammar/"
"Tokens` file."
msgstr ""

#: ../../internals/parser.rst:574
msgid ""
"Rule names starting with ``invalid_`` are used for specialized syntax errors."
msgstr ""

#: ../../internals/parser.rst:576
msgid "These rules are NOT used in the first pass of the parser."
msgstr ""

#: ../../internals/parser.rst:577
msgid ""
"Only if the first pass fails to parse, a second pass including the invalid "
"rules will be executed."
msgstr ""

#: ../../internals/parser.rst:579
msgid ""
"If the parser fails in the second phase with a generic syntax error, the "
"location of the generic failure of the first pass will be used (this avoids "
"reporting incorrect locations due to the invalid rules)."
msgstr ""

#: ../../internals/parser.rst:582
msgid ""
"The order of the alternatives involving invalid rules matter (like any rule "
"in PEG)."
msgstr ""

#: ../../internals/parser.rst:586
msgid "Tokenization"
msgstr ""

#: ../../internals/parser.rst:588
msgid ""
"It is common among PEG parser frameworks that the parser does both the "
"parsing and the tokenization, but this does not happen in Pegen. The reason "
"is that the Python language needs a custom tokenizer to handle things like "
"indentation boundaries, some special keywords like ``ASYNC`` and ``AWAIT`` "
"(for compatibility purposes), backtracking errors (such as unclosed "
"parenthesis), dealing with encoding, interactive mode and much more. Some of "
"these reasons are also there for historical purposes, and some others are "
"useful even today."
msgstr ""

#: ../../internals/parser.rst:595
msgid ""
"The list of tokens (all uppercase names in the grammar) that you can use can "
"be found in the :cpy-file:`Grammar/Tokens` file. If you change this file to "
"add new tokens, make sure to regenerate the files by executing: ::"
msgstr ""

#: ../../internals/parser.rst:600
msgid ""
"If you are on Windows you can use the Visual Studio project files to "
"regenerate the tokens or to execute: ::"
msgstr ""

#: ../../internals/parser.rst:604
msgid ""
"How tokens are generated and the rules governing this is completely up to "
"the tokenizer (:cpy-file:`Parser/tokenizer.c`) and the parser just receives "
"tokens from it."
msgstr ""

#: ../../internals/parser.rst:608
msgid "Memoization"
msgstr ""

#: ../../internals/parser.rst:610
msgid ""
"As described previously, to avoid exponential time complexity in the parser, "
"memoization is used."
msgstr ""

#: ../../internals/parser.rst:612
msgid ""
"The C parser used by Python is highly optimized and memoization can be "
"expensive both in memory and time. Although the memory cost is obvious (the "
"parser needs memory for storing previous results in the cache) the execution "
"time cost comes for continuously checking if the given rule has a cache hit "
"or not. In many situations, just parsing it again can be faster. Pegen "
"**disables memoization by default** except for rules with the special marker "
"``memo`` after the rule name (and type, if present): ::"
msgstr ""

#: ../../internals/parser.rst:621
msgid ""
"By selectively turning on memoization for a handful of rules, the parser "
"becomes faster and uses less memory."
msgstr ""

#: ../../internals/parser.rst:624
msgid ""
"Left-recursive rules always use memoization, since the implementation of "
"left-recursion depends on it."
msgstr ""

#: ../../internals/parser.rst:626
msgid ""
"To know if a new rule needs memoization or not, benchmarking is required "
"(comparing execution times and memory usage of some considerably big files "
"with and without memoization). There is a very simple instrumentation API "
"available in the generated C parse code that allows to measure how much each "
"rule uses memoization (check the :cpy-file:`Parser/pegen.c` file for more "
"information) but it needs to be manually activated."
msgstr ""

#: ../../internals/parser.rst:634
msgid "Automatic variables"
msgstr ""

#: ../../internals/parser.rst:636
msgid ""
"To make writing actions easier, Pegen injects some automatic variables in "
"the namespace available when writing actions. In the C parser, some of these "
"automatic variable names are:"
msgstr ""

#: ../../internals/parser.rst:639
msgid "``p``: The parser structure."
msgstr ""

#: ../../internals/parser.rst:640
msgid ""
"``EXTRA``: This is a macro that expands to ``(_start_lineno, "
"_start_col_offset, _end_lineno, _end_col_offset, p->arena)``, which is "
"normally used to create AST nodes as almost all constructors need these "
"attributes to be provided. All of the location variables are taken from the "
"location information of the current token."
msgstr ""

#: ../../internals/parser.rst:645
msgid "Hard and Soft keywords"
msgstr ""

#: ../../internals/parser.rst:648
msgid ""
"In the grammar files, keywords are defined using **single quotes** (e.g. "
"``'class'``) while soft keywords are defined using **double quotes** (e.g. "
"``\"match\"``)."
msgstr ""

#: ../../internals/parser.rst:651
msgid ""
"There are two kinds of keywords allowed in pegen grammars: *hard* and *soft* "
"keywords. The difference between hard and soft keywords is that hard "
"keywords are always reserved words, even in positions where they make no "
"sense (e.g. ``x = class + 1``), while soft keywords only get a special "
"meaning in context. Trying to use a hard keyword as a variable will always "
"fail:"
msgstr ""

#: ../../internals/parser.rst:670
msgid ""
"While soft keywords don't have this limitation if used in a context other "
"the one where they are defined as keywords:"
msgstr ""

#: ../../internals/parser.rst:678
msgid ""
"The ``match`` and ``case`` keywords are soft keywords, so that they are "
"recognized as keywords at the beginning of a match statement or case block "
"respectively, but are allowed to be used in other places as variable or "
"argument names."
msgstr ""

#: ../../internals/parser.rst:682
msgid "You can get a list of all keywords defined in the grammar from Python:"
msgstr ""

#: ../../internals/parser.rst:693
msgid "as well as soft keywords:"
msgstr ""

#: ../../internals/parser.rst:702
msgid ""
"Soft keywords can be a bit challenging to manage as they can be accepted in "
"places you don't intend to, given how the order alternatives behave in PEG "
"parsers (see :ref:`consequences of ordered choice section <consequences-of-"
"ordered-choice>` for some background on this). In general, try to define "
"them in places where there is not a lot of alternatives."
msgstr ""

#: ../../internals/parser.rst:709
msgid "Error handling"
msgstr ""

#: ../../internals/parser.rst:711
msgid ""
"When a pegen-generated parser detects that an exception is raised, it will "
"**automatically stop parsing**, no matter what the current state of the "
"parser is and it will unwind the stack and report the exception. This means "
"that if a :ref:`rule action <peg-grammar-actions>` raises an exception all "
"parsing will stop at that exact point. This is done to allow to correctly "
"propagate any exception set by calling Python C-API functions. This also "
"includes :exc:`SyntaxError` exceptions and this is the main mechanism the "
"parser uses to report custom syntax error messages."
msgstr ""

#: ../../internals/parser.rst:721
msgid ""
"Tokenizer errors are normally reported by raising exceptions but some "
"special tokenizer errors such as unclosed parenthesis will be reported only "
"after the parser finishes without returning anything."
msgstr ""

#: ../../internals/parser.rst:726
msgid "How Syntax errors are reported"
msgstr ""

#: ../../internals/parser.rst:728
msgid ""
"As described previously in the :ref:`how PEG parsers work section <how-peg-"
"parsers-work>`, PEG parsers don't have a defined concept of where errors "
"happened in the grammar, because a rule failure doesn't imply a parsing "
"failure like in context free grammars. This means that some heuristic has to "
"be used to report generic errors unless something is explicitly declared as "
"an error in the grammar."
msgstr ""

#: ../../internals/parser.rst:735
msgid ""
"To report generic syntax errors, pegen uses a common heuristic in PEG "
"parsers: the location of *generic* syntax errors is reported in the furthest "
"token that was attempted to be matched but failed. This is only done if "
"parsing has failed (the parser returns ``NULL`` in C or ``None`` in Python) "
"but no exception has been raised."
msgstr ""

#: ../../internals/parser.rst:742
msgid ""
"Positive and negative lookaheads will try to match a token so they will "
"affect the location of generic syntax errors. Use them carefully at "
"boundaries between rules."
msgstr ""

#: ../../internals/parser.rst:746
msgid ""
"As the Python grammar was primordially written as an LL(1) grammar, this "
"heuristic has an extremely high success rate, but some PEG features can have "
"small effects, such as :ref:`positive lookaheads <peg-positive-lookahead>` "
"and :ref:`negative lookaheads <peg-negative-lookahead>`."
msgstr ""

#: ../../internals/parser.rst:751
msgid ""
"To generate more precise syntax errors, custom rules are used. This is a "
"common practice also in context free grammars: the parser will try to accept "
"some construct that is known to be incorrect just to report a specific "
"syntax error for that construct. In pegen grammars, these rules start with "
"the ``invalid_`` prefix. This is because trying to match these rules "
"normally has a performance impact on parsing (and can also affect the "
"'correct' grammar itself in some tricky cases, depending on the ordering of "
"the rules) so the generated parser acts in two phases:"
msgstr ""

#: ../../internals/parser.rst:759
msgid ""
"The first phase will try to parse the input stream without taking into "
"account rules that start with the ``invalid_`` prefix. If the parsing "
"succeeds it will return the generated AST and the second phase will not be "
"attempted."
msgstr ""

#: ../../internals/parser.rst:763
msgid ""
"If the first phase failed, a second parsing attempt is done including the "
"rules that start with an ``invalid_`` prefix. By design this attempt "
"**cannot succeed** and is only executed to give to the invalid rules a "
"chance to detect specific situations where custom, more precise, syntax "
"errors can be raised. This also allows to trade a bit of performance for "
"precision reporting errors: given that we know that the input text is "
"invalid, there is no need to be fast because the interpreter is going to "
"stop anyway."
msgstr ""

#: ../../internals/parser.rst:771
msgid "When defining invalid rules:"
msgstr ""

#: ../../internals/parser.rst:773
msgid ""
"Make sure all custom invalid rules raise :exc:`SyntaxError` exceptions (or a "
"subclass of it)."
msgstr ""

#: ../../internals/parser.rst:774
msgid ""
"Make sure **all** invalid rules start with the ``invalid_`` prefix to not "
"impact performance of parsing correct Python code."
msgstr ""

#: ../../internals/parser.rst:776
msgid ""
"Make sure the parser doesn't behave differently for regular rules when you "
"introduce invalid rules (see the :ref:`how PEG parsers work section <how-peg-"
"parsers-work>` for more information)."
msgstr ""

#: ../../internals/parser.rst:779
msgid ""
"You can find a collection of macros to raise specialized syntax errors in "
"the :cpy-file:`Parser/pegen.h` header file. These macros allow also to "
"report ranges for the custom errors that will be highlighted in the "
"tracebacks that will be displayed when the error is reported."
msgstr ""

#: ../../internals/parser.rst:785
msgid ""
"A good way to test if an invalid rule will be triggered when you expect is "
"to test if introducing a syntax error **after** valid code triggers the rule "
"or not. For example: ::"
msgstr ""

#: ../../internals/parser.rst:790
msgid ""
"Should trigger the syntax error in the ``$`` character. If your rule is not "
"correctly defined this won't happen. For example, if you try to define a "
"rule to match Python 2 style ``print`` statements to make a better error "
"message and you define it as: ::"
msgstr ""

#: ../../internals/parser.rst:796
msgid ""
"This will **seem** to work because the parser will correctly parse "
"``print(something)`` because it is valid code and the second phase will "
"never execute but if you try to parse ``print(something) $ 3`` the first "
"pass of the parser will fail (because of the ``$``) and in the second phase, "
"the rule will match the ``print(something)`` as ``print`` followed by the "
"variable ``something`` between parentheses and the error will be reported "
"there instead of the ``$`` character."
msgstr ""

#: ../../internals/parser.rst:803
msgid "Generating AST objects"
msgstr ""

#: ../../internals/parser.rst:805
msgid ""
"The output of the C parser used by CPython that is generated by the :cpy-"
"file:`Grammar/python.gram` grammar file is a Python AST object (using C "
"structures). This means that the actions in the grammar file generate AST "
"objects when they succeed. Constructing these objects can be quite "
"cumbersome (see the :ref:`AST compiler section <compiler-ast-trees>` for "
"more information on how these objects are constructed and how they are used "
"by the compiler) so special helper functions are used. These functions are "
"declared in the :cpy-file:`Parser/pegen.h` header file and defined in the :"
"cpy-file:`Parser/action_helpers.c` file. These functions allow you to join "
"AST sequences, get specific elements from them or to do extra processing on "
"the generated tree."
msgstr ""

#: ../../internals/parser.rst:817
msgid ""
"Actions must **never** be used to accept or reject rules. It may be tempting "
"in some situations to write a very generic rule and then check the generated "
"AST to decide if is valid or not but this will render the `official grammar "
"<https://docs.python.org/3/reference/grammar.html>`_ partially incorrect "
"(because actions are not included) and will make it more difficult for other "
"Python implementations to adapt the grammar to their own needs."
msgstr ""

#: ../../internals/parser.rst:824
msgid ""
"As a general rule, if an action spawns multiple lines or requires something "
"more complicated than a single expression of C code, is normally better to "
"create a custom helper in :cpy-file:`Parser/action_helpers.c` and expose it "
"in the :cpy-file:`Parser/pegen.h` header file so it can be used from the "
"grammar."
msgstr ""

#: ../../internals/parser.rst:829
msgid ""
"If the parsing succeeds, the parser **must** return a **valid** AST object."
msgstr ""

#: ../../internals/parser.rst:832
msgid "Testing"
msgstr ""

#: ../../internals/parser.rst:834
msgid ""
"There are three files that contain tests for the grammar and the parser:"
msgstr ""

#: ../../internals/parser.rst:836
msgid ":cpy-file:`Lib/test/test_grammar.py`"
msgstr ""

#: ../../internals/parser.rst:837
msgid ":cpy-file:`Lib/test/test_syntax.py`"
msgstr ""

#: ../../internals/parser.rst:838
msgid ":cpy-file:`Lib/test/test_exceptions.py`"
msgstr ""

#: ../../internals/parser.rst:840
msgid ""
"Check the contents of these files to know which is the best place to place "
"new tests depending on the nature of the new feature you are adding."
msgstr ""

#: ../../internals/parser.rst:843
msgid ""
"Tests for the parser generator itself can be found in the :cpy-file:`Lib/"
"test/test_peg_generator` directory."
msgstr ""

#: ../../internals/parser.rst:847
msgid "Debugging generated parsers"
msgstr ""

#: ../../internals/parser.rst:850
msgid "Making experiments"
msgstr ""

#: ../../internals/parser.rst:852
msgid ""
"As the generated C parser is the one used by Python, this means that if "
"something goes wrong when adding some new rules to the grammar you cannot "
"correctly compile and execute Python anymore. This makes it a bit "
"challenging to debug when something goes wrong, especially when making "
"experiments."
msgstr ""

#: ../../internals/parser.rst:856
msgid ""
"For this reason it is a good idea to experiment first by generating a Python "
"parser. To do this, you can go to the :cpy-file:`Tools/peg_generator/` "
"directory on the CPython repository and manually call the parser generator "
"by executing:"
msgstr ""

#: ../../internals/parser.rst:863
msgid ""
"This will generate a file called :file:`parse.py` in the same directory that "
"you can use to parse some input:"
msgstr ""

#: ../../internals/parser.rst:869
msgid ""
"As the generated :file:`parse.py` file is just Python code, you can modify "
"it and add breakpoints to debug or better understand some complex situations."
msgstr ""

#: ../../internals/parser.rst:874
msgid "Verbose mode"
msgstr ""

#: ../../internals/parser.rst:876
msgid ""
"When Python is compiled in debug mode (by adding ``--with-pydebug`` when "
"running the configure step in Linux or by adding ``-d`` when calling the :"
"cpy-file:`PCbuild/build.bat` script in Windows), it is possible to activate "
"a **very** verbose mode in the generated parser. This is very useful to "
"debug the generated parser and to understand how it works, but it can be a "
"bit hard to understand at first."
msgstr ""

#: ../../internals/parser.rst:883
msgid ""
"When activating verbose mode in the Python parser, it is better to not use "
"interactive mode as it can be much harder to understand, because interactive "
"mode involves some special steps compared to regular parsing."
msgstr ""

#: ../../internals/parser.rst:886
msgid ""
"To activate verbose mode you can add the ``-d`` flag when executing Python:"
msgstr ""

#: ../../internals/parser.rst:892
msgid ""
"This will print **a lot** of output to ``stderr`` so is probably better to "
"dump it to a file for further analysis. The output consists of trace lines "
"with the following structure:"
msgstr ""

#: ../../internals/parser.rst:895
msgid ""
"<indentation> ('>'|'-'|'+'|'!') <rule_name>[<token_location>]: "
"<alternative> ..."
msgstr ""

#: ../../internals/parser.rst:897
msgid ""
"Every line is indented by a different amount (``<indentation>``) depending "
"on how deep the call stack is. The next character marks the type of the "
"trace:"
msgstr ""

#: ../../internals/parser.rst:900
msgid "``>`` indicates that a rule is going to be attempted to be parsed."
msgstr ""

#: ../../internals/parser.rst:901
msgid "``-`` indicates that a rule has failed to be parsed."
msgstr ""

#: ../../internals/parser.rst:902
msgid "``+`` indicates that a rule has been parsed correctly."
msgstr ""

#: ../../internals/parser.rst:903
msgid ""
"``!`` indicates that an exception or an error has been detected and the "
"parser is unwinding."
msgstr ""

#: ../../internals/parser.rst:905
msgid ""
"The <token_location> part indicates the current index in the token array, "
"the <rule_name> part indicates what rule is being parsed and the "
"<alternative> part indicates what alternative within that rule is being "
"attempted."
msgstr ""

#: ../../internals/parser.rst:911
msgid "References"
msgstr ""

#: ../../internals/parser.rst:913
msgid "Ford, Bryan https://pdos.csail.mit.edu/~baford/packrat/thesis/"
msgstr ""

#: ../../internals/parser.rst:916
msgid "Medeiros et al. https://arxiv.org/pdf/1207.0443.pdf"
msgstr ""

#: ../../internals/parser.rst:919
msgid "Warth et al. http://web.cs.ucla.edu/~todd/research/pepm08.pdf"
msgstr ""
