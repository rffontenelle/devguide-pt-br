# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2023, Python Software Foundation
# This file is distributed under the same license as the Python Developer's
# Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Developer's Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-17 11:38-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_BR\n"
"Language-Team: pt_BR <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"

#: ../../development-tools/clinic.rst:7
msgid "Argument Clinic"
msgstr ""

#: ../../development-tools/clinic.rst
msgid "author"
msgstr ""

#: ../../development-tools/clinic.rst:9
msgid "Larry Hastings"
msgstr ""

#: ../../development-tools/clinic.rst:11
msgid "**Source code:** :cpy-file:`Tools/clinic/clinic.py`."
msgstr ""

#: ../../development-tools/clinic.rst:13
msgid ""
"Argument Clinic is a preprocessor for CPython C files. It was introduced "
"in Python 3.4 with :pep:`436`, in order to provide introspection "
"signatures, and to generate performant and tailor-made boilerplate code "
"for argument parsing in CPython builtins, module level functions, and "
"class methods. This document is divided in four major sections:"
msgstr ""

#: ../../development-tools/clinic.rst:20
msgid ""
":ref:`clinic-background` talks about the basic concepts and goals of "
"Argument Clinic."
msgstr ""

#: ../../development-tools/clinic.rst:21
msgid ""
":ref:`clinic-reference` describes the command-line interface and Argument"
" Clinic terminology."
msgstr ""

#: ../../development-tools/clinic.rst:22
msgid ""
":ref:`clinic-tutorial` guides you through all the steps required to adapt"
" an existing C function to Argument Clinic."
msgstr ""

#: ../../development-tools/clinic.rst:23
msgid ":ref:`clinic-howtos` details how to handle specific tasks."
msgstr ""

#: ../../development-tools/clinic.rst:28
msgid ""
"Argument Clinic is considered internal-only for CPython.  Its use is not "
"supported for files outside CPython, and no guarantees are made regarding"
" backwards compatibility for future versions.  In other words: if you "
"maintain an external C extension for CPython, you're welcome to "
"experiment with Argument Clinic in your own code.  But the version of "
"Argument Clinic that ships with the next version of CPython *could* be "
"totally incompatible and break all your code."
msgstr ""

#: ../../development-tools/clinic.rst:41
msgid "Background"
msgstr ""

#: ../../development-tools/clinic.rst:44
msgid "Basic concepts"
msgstr ""

#: ../../development-tools/clinic.rst:46
msgid ""
"When Argument Clinic is run on a file, either via the :ref:`clinic-cli` "
"or via ``make clinic``, it will scan over the input files looking for "
":term:`start lines <start line>`:"
msgstr ""

#: ../../development-tools/clinic.rst:54
msgid "When it finds one, it reads everything up to the :term:`end line`:"
msgstr ""

#: ../../development-tools/clinic.rst:60
msgid ""
"Everything in between these two lines is Argument Clinic :term:`input`. "
"When Argument Clinic parses input, it generates :term:`output`. The "
"output is rewritten into the C file immediately after the input, followed"
" by a :term:`checksum line`. All of these lines, including the "
":term:`start line` and :term:`checksum line`, are collectively called an "
"Argument Clinic :term:`block`:"
msgstr ""

#: ../../development-tools/clinic.rst:75
msgid ""
"If you run Argument Clinic on the same file a second time, Argument "
"Clinic will discard the old :term:`output` and write out the new output "
"with a fresh :term:`checksum line`. If the :term:`input` hasn't changed, "
"the output won't change either."
msgstr ""

#: ../../development-tools/clinic.rst:82
msgid ""
"You should never modify the output of an Argument Clinic block, as any "
"change will be lost in future Argument Clinic runs; Argument Clinic will "
"detect an output checksum mismatch and regenerate the correct output. If "
"you are not happy with the generated output, you should instead change "
"the input until it produces the output you want."
msgstr ""

#: ../../development-tools/clinic.rst:93
msgid "Reference"
msgstr ""

#: ../../development-tools/clinic.rst:99
msgid "Terminology"
msgstr ""

#: ../../development-tools/clinic.rst:102
msgid "start line"
msgstr ""

#: ../../development-tools/clinic.rst:104
msgid ""
"The line ``/*[clinic input]``. This line marks the beginning of Argument "
"Clinic input. Note that the *start line* opens a C block comment."
msgstr ""

#: ../../development-tools/clinic.rst:107
msgid "end line"
msgstr ""

#: ../../development-tools/clinic.rst:109
msgid ""
"The line ``[clinic start generated code]*/``. The *end line* marks the "
"_end_ of Argument Clinic :term:`input`, but at the same time marks the "
"_start_ of Argument Clinic :term:`output`, thus the text *\"clinic start "
"start generated code\"* Note that the *end line* closes the C block "
"comment opened by the *start line*."
msgstr ""

#: ../../development-tools/clinic.rst:115
msgid "checksum"
msgstr ""

#: ../../development-tools/clinic.rst:117
msgid ""
"A hash to distinguish unique :term:`inputs <input>` and :term:`outputs "
"<output>`."
msgstr ""

#: ../../development-tools/clinic.rst:119
msgid "checksum line"
msgstr ""

#: ../../development-tools/clinic.rst:121
msgid ""
"A line that looks like ``/*[clinic end generated code: ...]*/``. The "
"three dots will be replaced by a :term:`checksum` generated from the "
":term:`input`, and a :term:`checksum` generated from the :term:`output`. "
"The checksum line marks the end of Argument Clinic generated code, and is"
" used by Argument Clinic to determine if it needs to regenerate output."
msgstr ""

#: ../../development-tools/clinic.rst:127
msgid "input"
msgstr ""

#: ../../development-tools/clinic.rst:129
msgid ""
"The text between the :term:`start line` and the :term:`end line`. Note "
"that the start and end lines open and close a C block comment; the "
"*input* is thus a part of that same C block comment."
msgstr ""

#: ../../development-tools/clinic.rst:132
msgid "output"
msgstr ""

#: ../../development-tools/clinic.rst:134
msgid "The text between the :term:`end line` and the :term:`checksum line`."
msgstr ""

#: ../../development-tools/clinic.rst:135
msgid "block"
msgstr ""

#: ../../development-tools/clinic.rst:137
msgid ""
"All text from the :term:`start line` to the :term:`checksum line` "
"inclusively."
msgstr ""

#: ../../development-tools/clinic.rst:143
msgid "Command-line interface"
msgstr ""

#: ../../development-tools/clinic.rst:145
msgid ""
"The Argument Clinic :abbr:`CLI (Command-Line Interface)` is typically "
"used to process a single source file, like this:"
msgstr ""

#: ../../development-tools/clinic.rst:152
msgid "The CLI supports the following options:"
msgstr ""

#: ../../development-tools/clinic.rst:159
msgid "Print CLI usage."
msgstr ""

#: ../../development-tools/clinic.rst:163
msgid "Force output regeneration."
msgstr ""

#: ../../development-tools/clinic.rst:167
msgid "Redirect file output to OUTPUT"
msgstr ""

#: ../../development-tools/clinic.rst:171
msgid "Enable verbose mode."
msgstr ""

#: ../../development-tools/clinic.rst:175
msgid "Print a list of all supported converters and return converters."
msgstr ""

#: ../../development-tools/clinic.rst:179
msgid "Walk :option:`--srcdir` to run over all relevant files."
msgstr ""

#: ../../development-tools/clinic.rst:183
msgid "The directory tree to walk in :option:`--make` mode."
msgstr ""

#: ../../development-tools/clinic.rst:187
msgid ""
"A file to exclude in :option:`--make` mode. This option can be given "
"multiple times."
msgstr ""

#: ../../development-tools/clinic.rst:192
msgid ""
"Use the :ref:`Limited API <limited-c-api>` to parse arguments in the "
"generated C code. See :ref:`clinic-howto-limited-capi`."
msgstr ""

#: ../../development-tools/clinic.rst:197
msgid "The list of files to process."
msgstr ""

#: ../../development-tools/clinic.rst:203
msgid "Classes for extending Argument Clinic"
msgstr ""

#: ../../development-tools/clinic.rst:209
msgid ""
"The base class for all converters. See :ref:`clinic-howto-custom-"
"converter` for how to subclass this class."
msgstr ""

#: ../../development-tools/clinic.rst:214
msgid ""
"The C type to use for this variable. :attr:`!type` should be a Python "
"string specifying the type, e.g. ``'int'``. If this is a pointer type, "
"the type string should end with ``' *'``."
msgstr ""

#: ../../development-tools/clinic.rst:221
msgid ""
"The Python default value for this parameter, as a Python value. Or the "
"magic value ``unspecified`` if there is no default."
msgstr ""

#: ../../development-tools/clinic.rst:226
msgid ""
":attr:`!default` as it should appear in Python code, as a string. Or "
"``None`` if there is no default."
msgstr ""

#: ../../development-tools/clinic.rst:232
msgid ""
":attr:`!default` as it should appear in C code, as a string. Or ``None`` "
"if there is no default."
msgstr ""

#: ../../development-tools/clinic.rst:238
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option "
"groups—although properly written code will never actually use this value,"
" the variable does get passed in to the impl, and the C compiler will "
"complain about the \"use\" of the uninitialized value.  This value should"
" always be a non-empty string."
msgstr ""

#: ../../development-tools/clinic.rst:250
msgid "The name of the C converter function, as a string."
msgstr ""

#: ../../development-tools/clinic.rst:254
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
"the name of the variable when passing it into the impl function."
msgstr ""

#: ../../development-tools/clinic.rst:260
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
"the name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""

#: ../../development-tools/clinic.rst:268
msgid "Tutorial"
msgstr ""

#: ../../development-tools/clinic.rst:270
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd "
"need to follow to convert a function to work with Argument Clinic.  Note "
"that for code you plan to check in to CPython, you really should take the"
" conversion farther, using some of the :ref:`advanced concepts <clinic-"
"howtos>` you'll see later on in the document, like :ref:`clinic-howto-"
"return-converters` and :ref:`clinic-howto-self-converter`. But we'll keep"
" it simple for this walkthrough so you can learn."
msgstr ""

#: ../../development-tools/clinic.rst:281
msgid ""
"First, make sure you're working with a freshly updated checkout of the "
"CPython trunk."
msgstr ""

#: ../../development-tools/clinic.rst:284
msgid ""
"Next, find a Python builtin that calls either :c:func:`PyArg_ParseTuple` "
"or :c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to "
"work with Argument Clinic yet. For this tutorial, we'll be using "
":py:meth:`_pickle.Pickler.dump <pickle.Pickler.dump>`."
msgstr ""

#: ../../development-tools/clinic.rst:290
msgid ""
"If the call to the :c:func:`!PyArg_Parse*` function uses any of the "
"following format units...:"
msgstr ""

#: ../../development-tools/clinic.rst:302
msgid ""
"... or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should"
" choose a different function. (See :ref:`clinic-howto-advanced-"
"converters` for those scenarios.)"
msgstr ""

#: ../../development-tools/clinic.rst:306
msgid ""
"Also, if the function has multiple calls to :c:func:`!PyArg_ParseTuple` "
"or :c:func:`PyArg_ParseTupleAndKeywords` where it supports different "
"types for the same argument, or if the function uses something besides "
":c:func:`!PyArg_Parse*` functions to parse its arguments, it probably "
"isn't suitable for conversion to Argument Clinic.  Argument Clinic "
"doesn't support generic functions or polymorphic parameters."
msgstr ""

#: ../../development-tools/clinic.rst:313
msgid ""
"Next, add the following boilerplate above the function, creating our "
"input block::"
msgstr ""

#: ../../development-tools/clinic.rst:319
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, "
"removing all the junk that makes it a properly quoted C string. When "
"you're done you should have just the text, based at the left margin, with"
" no line wider than 80 characters. Argument Clinic will preserve indents "
"inside the docstring."
msgstr ""

#: ../../development-tools/clinic.rst:325
msgid ""
"If the old docstring had a first line that looked like a function "
"signature, throw that line away; The docstring doesn't need it anymore "
"--- when you use :py:func:`help` on your builtin in the future, the first"
" line will be built automatically based on the function's signature."
msgstr ""

#: ../../development-tools/clinic.rst:330
msgid "Example docstring summary line::"
msgstr ""

#: ../../development-tools/clinic.rst:336
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain, so let's make sure it has one.  The \"summary\" line should be "
"a paragraph consisting of a single 80-column line at the beginning of the"
" docstring. (See :pep:`257` regarding docstring conventions.)"
msgstr ""

#: ../../development-tools/clinic.rst:342
msgid ""
"Our example docstring consists solely of a summary line, so the sample "
"code doesn't have to change for this step."
msgstr ""

#: ../../development-tools/clinic.rst:345
msgid ""
"Now, above the docstring, enter the name of the function, followed by a "
"blank line.  This should be the Python name of the function, and should "
"be the full dotted path to the function --- it should start with the name"
" of the module, include any sub-modules, and if the function is a method "
"on a class it should include the class name too."
msgstr ""

#: ../../development-tools/clinic.rst:352
msgid ""
"In our example, :mod:`!_pickle` is the module, :py:class:`!Pickler` is "
"the class, and :py:meth:`!dump` is the method, so the name becomes "
":py:meth:`!_pickle.Pickler.dump`::"
msgstr ""

#: ../../development-tools/clinic.rst:362
msgid ""
"If this is the first time that module or class has been used with "
"Argument Clinic in this C file, you must declare the module and/or class."
"  Proper Argument Clinic hygiene prefers declaring these in a separate "
"block somewhere near the top of the C file, in the same way that include "
"files and statics go at the top. In our sample code we'll just show the "
"two blocks next to each other."
msgstr ""

#: ../../development-tools/clinic.rst:370
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or "
":c:type:`PyTypeObject` as appropriate."
msgstr ""

#: ../../development-tools/clinic.rst:374
msgid ""
"When you declare a class, you must also specify two aspects of its type "
"in C: the type declaration you'd use for a pointer to an instance of this"
" class, and a pointer to the :c:type:`!PyTypeObject` for this class::"
msgstr ""

#: ../../development-tools/clinic.rst:389
msgid ""
"Declare each of the parameters to the function.  Each parameter should "
"get its own line.  All the parameter lines should be indented from the "
"function name and the docstring. The general form of these parameter "
"lines is as follows:"
msgstr ""

#: ../../development-tools/clinic.rst:398
msgid "If the parameter has a default value, add that after the converter:"
msgstr ""

#: ../../development-tools/clinic.rst:405
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"see :ref:`clinic-howto-default-values` for more information."
msgstr ""

#: ../../development-tools/clinic.rst:408
msgid "Next, add a blank line below the parameters."
msgstr ""

#: ../../development-tools/clinic.rst:410
msgid ""
"What's a \"converter\"? It establishes both the type of the variable used"
" in C, and the method to convert the Python value into a C value at "
"runtime. For now you're going to use what's called a \"legacy converter\""
" --- a convenience syntax intended to make porting old code into Argument"
" Clinic easier."
msgstr ""

#: ../../development-tools/clinic.rst:417
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
":c:func:`PyArg_Parse` format argument and specify *that* as its "
"converter, as a quoted string. The \"format unit\" is the formal name for"
" the one-to-three character substring of the *format* parameter that "
"tells the argument parsing function what the type of the variable is and "
"how to convert it. For more on format units please see :ref:`arg-"
"parsing`."
msgstr ""

#: ../../development-tools/clinic.rst:426
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr ""

#: ../../development-tools/clinic.rst:429
#: ../../development-tools/clinic.rst:464
#: ../../development-tools/clinic.rst:492
#: ../../development-tools/clinic.rst:598
#: ../../development-tools/clinic.rst:651
msgid "Sample::"
msgstr ""

#: ../../development-tools/clinic.rst:444
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it. Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""

#: ../../development-tools/clinic.rst:449
msgid ""
"If your function has ``$`` in the format string, meaning it takes "
"keyword-only arguments, specify ``*`` on a line by itself before the "
"first keyword-only argument, indented the same as the parameter lines."
msgstr ""

#: ../../development-tools/clinic.rst:454
msgid ":py:meth:`!_pickle.Pickler.dump` has neither, so our sample is unchanged."
msgstr ""

#: ../../development-tools/clinic.rst:456
msgid ""
"Next, if the existing C function calls :c:func:`PyArg_ParseTuple` (as "
"opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments"
" are positional-only."
msgstr ""

#: ../../development-tools/clinic.rst:460
msgid ""
"To mark parameters as positional-only in Argument Clinic, add a ``/`` on "
"a line by itself after the last positional-only parameter, indented the "
"same as the parameter lines."
msgstr ""

#: ../../development-tools/clinic.rst:480
msgid ""
"It can be helpful to write a per-parameter docstring for each parameter. "
"Since per-parameter docstrings are optional, you can skip this step if "
"you prefer."
msgstr ""

#: ../../development-tools/clinic.rst:484
msgid ""
"Nevertheless, here's how to add a per-parameter docstring. The first line"
" of the per-parameter docstring must be indented further than the "
"parameter definition. The left margin of this first line establishes the "
"left margin for the whole per-parameter docstring; all the text you write"
" will be outdented by this amount. You can write as much text as you "
"like, across multiple lines if you wish."
msgstr ""

#: ../../development-tools/clinic.rst:509
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it. With "
"luck everything worked---your block now has output, and a :file:`.c.h` "
"file has been generated! Reload the file in your text editor to see the "
"generated code::"
msgstr ""

#: ../../development-tools/clinic.rst:528
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input. Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""

#: ../../development-tools/clinic.rst:533
msgid ""
"For readability, most of the glue code has been generated to a "
":file:`.c.h` file.  You'll need to include that in your original "
":file:`.c` file, typically right after the clinic module block::"
msgstr ""

#: ../../development-tools/clinic.rst:539
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated "
"looks basically the same as the existing code."
msgstr ""

#: ../../development-tools/clinic.rst:542
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords`; ensure that the code generated by "
"Argument Clinic calls the *exact* same function."
msgstr ""

#: ../../development-tools/clinic.rst:548
msgid ""
"Second, the format string passed in to :c:func:`!PyArg_ParseTuple` or "
":c:func:`!PyArg_ParseTupleAndKeywords` should be *exactly* the same as "
"the hand-written one in the existing function, up to the colon or semi-"
"colon."
msgstr ""

#: ../../development-tools/clinic.rst:553
msgid ""
"Argument Clinic always generates its format strings with a ``:`` followed"
" by the name of the function. If the existing code's format string ends "
"with ``;``, to provide usage help, this change is harmless --- don't "
"worry about it."
msgstr ""

#: ../../development-tools/clinic.rst:558
msgid ""
"Third, for parameters whose format units require two arguments, like a "
"length variable, an encoding string, or a pointer to a conversion "
"function, ensure that the second argument is *exactly* the same between "
"the two invocations."
msgstr ""

#: ../../development-tools/clinic.rst:563
msgid ""
"Fourth, inside the output portion of the block, you'll find a "
"preprocessor macro defining the appropriate static :c:type:`PyMethodDef` "
"structure for this builtin::"
msgstr ""

#: ../../development-tools/clinic.rst:570
msgid ""
"This static structure should be *exactly* the same as the existing static"
" :c:type:`!PyMethodDef` structure for this builtin."
msgstr ""

#: ../../development-tools/clinic.rst:573
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they "
"*are* the same."
msgstr ""

#: ../../development-tools/clinic.rst:577
msgid ""
"Notice that the last line of its output is the declaration of your "
"\"impl\" function.  This is where the builtin's implementation goes. "
"Delete the existing prototype of the function you're modifying, but leave"
" the opening curly brace.  Now delete its argument parsing code and the "
"declarations of all the variables it dumps the arguments into. Notice how"
" the Python arguments are now arguments to this impl function; if the "
"implementation used different names for these variables, fix it."
msgstr ""

#: ../../development-tools/clinic.rst:585
msgid ""
"Let's reiterate, just because it's kind of weird. Your code should now "
"look like this::"
msgstr ""

#: ../../development-tools/clinic.rst:594
msgid ""
"Argument Clinic generated the checksum line and the function prototype "
"just above it.  You should write the opening and closing curly braces for"
" the function, and the implementation inside."
msgstr ""

#: ../../development-tools/clinic.rst:640
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function? Find the existing :c:type:`!PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  If the builtin is"
" at module scope, this will probably be very near the end of the file; if"
" the builtin is a class method, this will probably be below but "
"relatively near to the implementation."
msgstr ""

#: ../../development-tools/clinic.rst:647
msgid ""
"Note that the body of the macro contains a trailing comma; when you "
"replace the existing static :c:type:`!PyMethodDef` structure with the "
"macro, *don't* add a comma to the end."
msgstr ""

#: ../../development-tools/clinic.rst:659
msgid "Argument Clinic may generate new instances of ``_Py_ID``. For example::"
msgstr ""

#: ../../development-tools/clinic.rst:663
msgid ""
"If it does, you'll have to run ``make regen-global-objects`` to "
"regenerate the list of precompiled identifiers at this point."
msgstr ""

#: ../../development-tools/clinic.rst:666
msgid ""
"Finally, compile, then run the relevant portions of the regression-test "
"suite. This change should not introduce any new compile-time warnings or "
"errors, and there should be no externally visible change to Python's "
"behavior, except for one difference: :py:func:`inspect.signature` run on "
"your function should now provide a valid signature!"
msgstr ""

#: ../../development-tools/clinic.rst:672
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr ""

#: ../../development-tools/clinic.rst:678
msgid "How-to guides"
msgstr ""

#: ../../development-tools/clinic.rst:682
msgid "How to rename C functions and variables generated by Argument Clinic"
msgstr ""

#: ../../development-tools/clinic.rst:684
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides "
"with the name of an existing C function.  There's an easy solution: "
"override the names used for the C functions.  Just add the keyword "
"``\"as\"`` to your function declaration line, followed by the function "
"name you wish to use. Argument Clinic will use that function name for the"
" base (generated) function, then add ``\"_impl\"`` to the end and use "
"that for the name of the impl function."
msgstr ""

#: ../../development-tools/clinic.rst:692
msgid ""
"For example, if we wanted to rename the C function names generated for "
":py:meth:`pickle.Pickler.dump`, it'd look like this::"
msgstr ""

#: ../../development-tools/clinic.rst:700
msgid ""
"The base function would now be named :c:func:`!pickler_dumper`, and the "
"impl function would now be named :c:func:`!pickler_dumper_impl`."
msgstr ""

#: ../../development-tools/clinic.rst:704
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C,"
" using the same ``\"as\"`` syntax::"
msgstr ""

#: ../../development-tools/clinic.rst:718
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` "
"array) would be *file*, but the C variable would be named ``file_obj``."
msgstr ""

#: ../../development-tools/clinic.rst:721
msgid "You can use this to rename the *self* parameter too!"
msgstr ""

#: ../../development-tools/clinic.rst:725
msgid "How to convert functions using ``PyArg_UnpackTuple``"
msgstr ""

#: ../../development-tools/clinic.rst:727
msgid ""
"To convert a function parsing its arguments with "
":c:func:`PyArg_UnpackTuple`, simply write out all the arguments, "
"specifying each as an ``object``.  You may specify the *type* argument to"
" cast the type as appropriate.  All arguments should be marked "
"positional-only (add a ``/`` on a line by itself after the last "
"argument)."
msgstr ""

#: ../../development-tools/clinic.rst:733
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but "
"this will change soon."
msgstr ""

#: ../../development-tools/clinic.rst:738
msgid "How to use optional groups"
msgstr ""

#: ../../development-tools/clinic.rst:740
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` "
"calls depending on how many positional arguments there are.  (These "
"functions cannot accept keyword-only arguments.)  This approach was used "
"to simulate optional arguments back before "
":c:func:`PyArg_ParseTupleAndKeywords` was created."
msgstr ""

#: ../../development-tools/clinic.rst:747
msgid ""
"While functions using this approach can often be converted to use "
":c:func:`!PyArg_ParseTupleAndKeywords`, optional arguments, and default "
"values, it's not always possible.  Some of these legacy functions have "
"behaviors :c:func:`!PyArg_ParseTupleAndKeywords` doesn't directly "
"support. The most obvious example is the builtin function "
":py:func:`!range`, which has an optional argument on the *left* side of "
"its required argument! Another example is :py:meth:`curses.window.addch`,"
" which has a group of two arguments that must always be specified "
"together.  (The arguments are called *x* and *y*; if you call the "
"function passing in *x*, you must also pass in *y* — and if you don't "
"pass in *x* you may not pass in *y* either.)"
msgstr ""

#: ../../development-tools/clinic.rst:759
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing "
"for all existing CPython builtins without changing their semantics. "
"Therefore Argument Clinic supports this alternate approach to parsing, "
"using what are called *optional groups*. Optional groups are groups of "
"arguments that must all be passed in together. They can be to the left or"
" the right of the required arguments.  They can *only* be used with "
"positional-only parameters."
msgstr ""

#: ../../development-tools/clinic.rst:767
msgid ""
"Optional groups are *only* intended for use when converting functions "
"that make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that "
"use *any* other approach for parsing arguments should *almost never* be "
"converted to Argument Clinic using optional groups.  Functions using "
"optional groups currently cannot have accurate signatures in Python, "
"because Python just doesn't understand the concept.  Please avoid using "
"optional groups wherever possible."
msgstr ""

#: ../../development-tools/clinic.rst:776
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself "
"after these parameters.  As an example, here's how "
":py:meth:`curses.window.addch` uses optional groups to make the first two"
" parameters and the last parameter optional::"
msgstr ""

#: ../../development-tools/clinic.rst:805
msgid "Notes:"
msgstr ""

#: ../../development-tools/clinic.rst:807
msgid ""
"For every optional group, one additional parameter will be passed into "
"the impl function representing the group.  The parameter will be an int "
"named ``group_{direction}_{number}``, where ``{direction}`` is either "
"``right`` or ``left`` depending on whether the group is before or after "
"the required parameters, and ``{number}`` is a monotonically increasing "
"number (starting at 1) indicating how far away the group is from the "
"required parameters.  When the impl is called, this parameter will be set"
" to zero if this group was unused, and set to non-zero if this group was "
"used. (By used or unused, I mean whether or not the parameters received "
"arguments in this invocation.)"
msgstr ""

#: ../../development-tools/clinic.rst:818
msgid ""
"If there are no required arguments, the optional groups will behave as if"
" they're to the right of the required arguments."
msgstr ""

#: ../../development-tools/clinic.rst:821
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on "
"the left (before the required parameters)."
msgstr ""

#: ../../development-tools/clinic.rst:824
msgid "Optional groups can only contain positional-only parameters."
msgstr ""

#: ../../development-tools/clinic.rst:826
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr ""

#: ../../development-tools/clinic.rst:831
msgid ""
"How to use real Argument Clinic converters, instead of \"legacy "
"converters\""
msgstr ""

#: ../../development-tools/clinic.rst:833
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed"
" explicitly to make porting existing code to Argument Clinic easier.  And"
" to be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""

#: ../../development-tools/clinic.rst:840
msgid ""
"However, in the long term we probably want all our blocks to use Argument"
" Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""

#: ../../development-tools/clinic.rst:844
msgid "The proper converters are far easier to read and clearer in their intent."
msgstr ""

#: ../../development-tools/clinic.rst:845
msgid ""
"There are some format units that are unsupported as \"legacy "
"converters\", because they require arguments, and the legacy converter "
"syntax doesn't support specifying arguments."
msgstr ""

#: ../../development-tools/clinic.rst:848
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""

#: ../../development-tools/clinic.rst:852
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal"
" converters instead of legacy converters."
msgstr ""

#: ../../development-tools/clinic.rst:855
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters "
"looks like a Python function call.  However, if there are no explicit "
"arguments to the function (all functions take their default values), you "
"may omit the parentheses.  Thus ``bool`` and ``bool()`` are exactly the "
"same converters."
msgstr ""

#: ../../development-tools/clinic.rst:861
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All "
"Argument Clinic converters accept the following arguments:"
msgstr ""

#: ../../development-tools/clinic.rst:869
msgid "*c_default*"
msgstr ""

#: ../../development-tools/clinic.rst:865
msgid ""
"The default value for this parameter when defined in C. Specifically, "
"this will be the initializer for the variable declared in the \"parse "
"function\".  See :ref:`the section on default values <default_values>` "
"for how to use this. Specified as a string."
msgstr ""

#: ../../development-tools/clinic.rst:874
msgid "*annotation*"
msgstr ""

#: ../../development-tools/clinic.rst:872
msgid ""
"The annotation value for this parameter.  Not currently supported, "
"because :pep:`8` mandates that the Python library may not use "
"annotations."
msgstr ""

#: ../../development-tools/clinic.rst:877
msgid "*unused*"
msgstr ""

#: ../../development-tools/clinic.rst:877
msgid ""
"Wrap the argument with :c:macro:`Py_UNUSED` in the impl function "
"signature."
msgstr ""

#: ../../development-tools/clinic.rst:879
msgid ""
"In addition, some converters accept additional arguments.  Here is a list"
" of these arguments, along with their meanings:"
msgstr ""

#: ../../development-tools/clinic.rst:888
msgid "*accept*"
msgstr ""

#: ../../development-tools/clinic.rst:883
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a "
"general-purpose facility; as a rule it only supports specific lists of "
"types as shown in the legacy converter table.)"
msgstr ""

#: ../../development-tools/clinic.rst:888
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr ""

#: ../../development-tools/clinic.rst:893
msgid "*bitwise*"
msgstr ""

#: ../../development-tools/clinic.rst:891
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range "
"checking, even for negative values."
msgstr ""

#: ../../development-tools/clinic.rst:898
msgid "*converter*"
msgstr ""

#: ../../development-tools/clinic.rst:896
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a "
":ref:`C \"converter function\" <o_ampersand>` to use to convert this "
"object to a native type."
msgstr ""

#: ../../development-tools/clinic.rst:903
msgid "*encoding*"
msgstr ""

#: ../../development-tools/clinic.rst:901
msgid ""
"Only supported for strings.  Specifies the encoding to use when "
"converting this string from a Python str (Unicode) value into a C ``char "
"*`` value."
msgstr ""

#: ../../development-tools/clinic.rst:907
msgid "*subclass_of*"
msgstr ""

#: ../../development-tools/clinic.rst:906
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python "
"value be a subclass of a Python type, as expressed in C."
msgstr ""

#: ../../development-tools/clinic.rst:912
msgid "*type*"
msgstr ""

#: ../../development-tools/clinic.rst:910
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the"
" C type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr ""

#: ../../development-tools/clinic.rst:918
msgid "*zeroes*"
msgstr ""

#: ../../development-tools/clinic.rst:915
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) "
"are permitted inside the value.  The length of the string will be passed "
"in to the impl function, just after the string parameter, as a parameter "
"named ``<parameter_name>_length``."
msgstr ""

#: ../../development-tools/clinic.rst:920
msgid ""
"Please note, not every possible combination of arguments will work. "
"Usually these arguments are implemented by specific "
":c:func:`PyArg_ParseTuple` *format units*, with specific behavior.  For "
"example, currently you cannot call ``unsigned_short`` without also "
"specifying ``bitwise=True``. Although it's perfectly reasonable to think "
"this would work, these semantics don't map to any existing format unit.  "
"So Argument Clinic doesn't support it.  (Or, at least, not yet.)"
msgstr ""

#: ../../development-tools/clinic.rst:928
msgid ""
"Below is a table showing the mapping of legacy converters into real "
"Argument Clinic converters.  On the left is the legacy converter, on the "
"right is the text you'd replace it with."
msgstr ""

#: ../../development-tools/clinic.rst:933
msgid "``'B'``"
msgstr ""

#: ../../development-tools/clinic.rst:933
msgid "``unsigned_char(bitwise=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:934
msgid "``'b'``"
msgstr ""

#: ../../development-tools/clinic.rst:934
msgid "``unsigned_char``"
msgstr ""

#: ../../development-tools/clinic.rst:935
msgid "``'c'``"
msgstr ""

#: ../../development-tools/clinic.rst:935
msgid "``char``"
msgstr ""

#: ../../development-tools/clinic.rst:936
msgid "``'C'``"
msgstr ""

#: ../../development-tools/clinic.rst:936
msgid "``int(accept={str})``"
msgstr ""

#: ../../development-tools/clinic.rst:937
msgid "``'d'``"
msgstr ""

#: ../../development-tools/clinic.rst:937
msgid "``double``"
msgstr ""

#: ../../development-tools/clinic.rst:938
msgid "``'D'``"
msgstr ""

#: ../../development-tools/clinic.rst:938
msgid "``Py_complex``"
msgstr ""

#: ../../development-tools/clinic.rst:939
msgid "``'es'``"
msgstr ""

#: ../../development-tools/clinic.rst:939
msgid "``str(encoding='name_of_encoding')``"
msgstr ""

#: ../../development-tools/clinic.rst:940
msgid "``'es#'``"
msgstr ""

#: ../../development-tools/clinic.rst:940
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:941
msgid "``'et'``"
msgstr ""

#: ../../development-tools/clinic.rst:941
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr ""

#: ../../development-tools/clinic.rst:942
msgid "``'et#'``"
msgstr ""

#: ../../development-tools/clinic.rst:942
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:943
msgid "``'f'``"
msgstr ""

#: ../../development-tools/clinic.rst:943
msgid "``float``"
msgstr ""

#: ../../development-tools/clinic.rst:944
msgid "``'h'``"
msgstr ""

#: ../../development-tools/clinic.rst:944
msgid "``short``"
msgstr ""

#: ../../development-tools/clinic.rst:945
msgid "``'H'``"
msgstr ""

#: ../../development-tools/clinic.rst:945
msgid "``unsigned_short(bitwise=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:946
msgid "``'i'``"
msgstr ""

#: ../../development-tools/clinic.rst:946
msgid "``int``"
msgstr ""

#: ../../development-tools/clinic.rst:947
msgid "``'I'``"
msgstr ""

#: ../../development-tools/clinic.rst:947
msgid "``unsigned_int(bitwise=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:948
msgid "``'k'``"
msgstr ""

#: ../../development-tools/clinic.rst:948
msgid "``unsigned_long(bitwise=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:949
msgid "``'K'``"
msgstr ""

#: ../../development-tools/clinic.rst:949
msgid "``unsigned_long_long(bitwise=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:950
msgid "``'l'``"
msgstr ""

#: ../../development-tools/clinic.rst:950
msgid "``long``"
msgstr ""

#: ../../development-tools/clinic.rst:951
msgid "``'L'``"
msgstr ""

#: ../../development-tools/clinic.rst:951
msgid "``long long``"
msgstr ""

#: ../../development-tools/clinic.rst:952
msgid "``'n'``"
msgstr ""

#: ../../development-tools/clinic.rst:952
msgid "``Py_ssize_t``"
msgstr ""

#: ../../development-tools/clinic.rst:953
msgid "``'O'``"
msgstr ""

#: ../../development-tools/clinic.rst:953
msgid "``object``"
msgstr ""

#: ../../development-tools/clinic.rst:954
msgid "``'O!'``"
msgstr ""

#: ../../development-tools/clinic.rst:954
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr ""

#: ../../development-tools/clinic.rst:955
msgid "``'O&'``"
msgstr ""

#: ../../development-tools/clinic.rst:955
msgid "``object(converter='name_of_c_function')``"
msgstr ""

#: ../../development-tools/clinic.rst:956
msgid "``'p'``"
msgstr ""

#: ../../development-tools/clinic.rst:956
msgid "``bool``"
msgstr ""

#: ../../development-tools/clinic.rst:957
msgid "``'S'``"
msgstr ""

#: ../../development-tools/clinic.rst:957
msgid "``PyBytesObject``"
msgstr ""

#: ../../development-tools/clinic.rst:958
msgid "``'s'``"
msgstr ""

#: ../../development-tools/clinic.rst:958
msgid "``str``"
msgstr ""

#: ../../development-tools/clinic.rst:959
msgid "``'s#'``"
msgstr ""

#: ../../development-tools/clinic.rst:959
msgid "``str(zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:960
msgid "``'s*'``"
msgstr ""

#: ../../development-tools/clinic.rst:960
msgid "``Py_buffer(accept={buffer, str})``"
msgstr ""

#: ../../development-tools/clinic.rst:961
msgid "``'U'``"
msgstr ""

#: ../../development-tools/clinic.rst:961
msgid "``unicode``"
msgstr ""

#: ../../development-tools/clinic.rst:962
msgid "``'u'``"
msgstr ""

#: ../../development-tools/clinic.rst:962
msgid "``wchar_t``"
msgstr ""

#: ../../development-tools/clinic.rst:963
msgid "``'u#'``"
msgstr ""

#: ../../development-tools/clinic.rst:963
msgid "``wchar_t(zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:964
msgid "``'w*'``"
msgstr ""

#: ../../development-tools/clinic.rst:964
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr ""

#: ../../development-tools/clinic.rst:965
msgid "``'Y'``"
msgstr ""

#: ../../development-tools/clinic.rst:965
msgid "``PyByteArrayObject``"
msgstr ""

#: ../../development-tools/clinic.rst:966
msgid "``'y'``"
msgstr ""

#: ../../development-tools/clinic.rst:966
msgid "``str(accept={bytes})``"
msgstr ""

#: ../../development-tools/clinic.rst:967
msgid "``'y#'``"
msgstr ""

#: ../../development-tools/clinic.rst:967
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:968
msgid "``'y*'``"
msgstr ""

#: ../../development-tools/clinic.rst:968
msgid "``Py_buffer``"
msgstr ""

#: ../../development-tools/clinic.rst:969
msgid "``'Z'``"
msgstr ""

#: ../../development-tools/clinic.rst:969
msgid "``wchar_t(accept={str, NoneType})``"
msgstr ""

#: ../../development-tools/clinic.rst:970
msgid "``'Z#'``"
msgstr ""

#: ../../development-tools/clinic.rst:970
msgid "``wchar_t(accept={str, NoneType}, zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:971
msgid "``'z'``"
msgstr ""

#: ../../development-tools/clinic.rst:971
msgid "``str(accept={str, NoneType})``"
msgstr ""

#: ../../development-tools/clinic.rst:972
msgid "``'z#'``"
msgstr ""

#: ../../development-tools/clinic.rst:972
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr ""

#: ../../development-tools/clinic.rst:973
msgid "``'z*'``"
msgstr ""

#: ../../development-tools/clinic.rst:973
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr ""

#: ../../development-tools/clinic.rst:976
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper"
" converter::"
msgstr ""

#: ../../development-tools/clinic.rst:989
msgid ""
"One advantage of real converters is that they're more flexible than "
"legacy converters.  For example, the ``unsigned_int`` converter (and all "
"the ``unsigned_`` converters) can be specified without ``bitwise=True``."
"  Their default behavior performs range checking on the value, and they "
"won't accept negative numbers.  You just can't do that with a legacy "
"converter!"
msgstr ""

#: ../../development-tools/clinic.rst:995
msgid ""
"Argument Clinic will show you all the converters it has available.  For "
"each converter it'll show you all the parameters it accepts, along with "
"the default value for each parameter. Just run ``Tools/clinic/clinic.py "
"--converters`` to see the full list."
msgstr ""

#: ../../development-tools/clinic.rst:1002
msgid "How to use the ``Py_buffer`` converter"
msgstr ""

#: ../../development-tools/clinic.rst:1004
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, "
"``'*y'``, or ``'z*'`` legacy converters), you *must* not call "
":c:func:`PyBuffer_Release` on the provided buffer. Argument Clinic "
"generates code that does it for you (in the parsing function)."
msgstr ""

#: ../../development-tools/clinic.rst:1013
msgid "How to use advanced converters"
msgstr ""

#: ../../development-tools/clinic.rst:1015
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr ""

#: ../../development-tools/clinic.rst:1018
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for "
"your first function.)  The argument you specified to the format unit is "
"now an argument to the converter; this argument is either *converter* "
"(for ``O&``), *subclass_of* (for ``O!``), or *encoding* (for all the "
"format units that start with ``e``)."
msgstr ""

#: ../../development-tools/clinic.rst:1026
msgid ""
"When using *subclass_of*, you may also want to use the other custom "
"argument for ``object()``: *type*, which lets you set the type actually "
"used for the parameter.  For example, if you want to ensure that the "
"object is a subclass of :c:var:`PyUnicode_Type`, you probably want to use"
" the converter ``object(type='PyUnicodeObject *', "
"subclass_of='&PyUnicode_Type')``."
msgstr ""

#: ../../development-tools/clinic.rst:1032
msgid ""
"One possible problem with using Argument Clinic: it takes away some "
"possible flexibility for the format units starting with ``e``.  When "
"writing a :c:func:`!PyArg_Parse*` call by hand, you could theoretically "
"decide at runtime what encoding string to pass to that call.   But now "
"this string must be hard-coded at Argument-Clinic-preprocessing-time.  "
"This limitation is deliberate; it made supporting this format unit much "
"easier, and may allow for future optimizations. This restriction doesn't "
"seem unreasonable; CPython itself always passes in static hard-coded "
"encoding strings for parameters whose format units start with ``e``."
msgstr ""

#: ../../development-tools/clinic.rst:1046
msgid "How to assign default values to parameter"
msgstr ""

#: ../../development-tools/clinic.rst:1048
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr ""

#: ../../development-tools/clinic.rst:1057
msgid "They can also use any of Python's built-in constants:"
msgstr ""

#: ../../development-tools/clinic.rst:1065
msgid ""
"There's also special support for a default value of ``NULL``, and for "
"simple expressions, documented in the following sections."
msgstr ""

#: ../../development-tools/clinic.rst:1070
msgid "The ``NULL`` default value"
msgstr ""

#: ../../development-tools/clinic.rst:1072
msgid ""
"For string and object parameters, you can set them to ``None`` to "
"indicate that there's no default.  However, that means the C variable "
"will be initialized to ``Py_None``.  For convenience's sakes, there's a "
"special value called ``NULL`` for just this reason: from Python's "
"perspective it behaves like a default value of ``None``, but the C "
"variable is initialized with ``NULL``."
msgstr ""

#: ../../development-tools/clinic.rst:1081
msgid "Symbolic default values"
msgstr ""

#: ../../development-tools/clinic.rst:1083
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr ""

#: ../../development-tools/clinic.rst:1086
msgid "Numeric constants (integer and float)"
msgstr ""

#: ../../development-tools/clinic.rst:1087
msgid "String constants"
msgstr ""

#: ../../development-tools/clinic.rst:1088
msgid "``True``, ``False``, and ``None``"
msgstr ""

#: ../../development-tools/clinic.rst:1089
msgid ""
"Simple symbolic constants like :py:data:`sys.maxsize`, which must start "
"with the name of the module"
msgstr ""

#: ../../development-tools/clinic.rst:1092
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr ""

#: ../../development-tools/clinic.rst:1097
msgid "Expressions as default values"
msgstr ""

#: ../../development-tools/clinic.rst:1099
msgid ""
"The default value for a parameter can be more than just a literal value. "
"It can be an entire expression, using math operators and looking up "
"attributes on objects.  However, this support isn't exactly simple, "
"because of some non-obvious semantics."
msgstr ""

#: ../../development-tools/clinic.rst:1104
msgid "Consider the following example:"
msgstr ""

#: ../../development-tools/clinic.rst:1110
msgid ""
":py:data:`sys.maxsize` can have different values on different platforms."
"  Therefore Argument Clinic can't simply evaluate that expression locally"
" and hard-code it in C.  So it stores the default in such a way that it "
"will get evaluated at runtime, when the user asks for the function's "
"signature."
msgstr ""

#: ../../development-tools/clinic.rst:1115
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if "
"your module has an attribute called :py:attr:`!max_widgets`, you may "
"simply use it:"
msgstr ""

#: ../../development-tools/clinic.rst:1123
msgid ""
"If the symbol isn't found in the current module, it fails over to looking"
" in :py:data:`sys.modules`.  That's how it can find "
":py:data:`sys.maxsize` for example. (Since you don't know in advance what"
" modules the user will load into their interpreter, it's best to restrict"
" yourself to modules that are preloaded by Python itself.)"
msgstr ""

#: ../../development-tools/clinic.rst:1128
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the "
"equivalent expression in C, using the *c_default* parameter to the "
"converter:"
msgstr ""

#: ../../development-tools/clinic.rst:1137
msgid ""
"Another complication: Argument Clinic can't know in advance whether or "
"not the expression you supply is valid.  It parses it to make sure it "
"looks legal, but it can't *actually* know.  You must be very careful when"
" using expressions to specify values that are guaranteed to be valid at "
"runtime!"
msgstr ""

#: ../../development-tools/clinic.rst:1142
msgid ""
"Finally, because expressions must be representable as static C values, "
"there are many restrictions on legal expressions.  Here's a list of "
"Python features you're not permitted to use:"
msgstr ""

#: ../../development-tools/clinic.rst:1146
msgid "Function calls."
msgstr ""

#: ../../development-tools/clinic.rst:1147
msgid "Inline if statements (``3 if foo else 5``)."
msgstr ""

#: ../../development-tools/clinic.rst:1148
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr ""

#: ../../development-tools/clinic.rst:1149
msgid "List/set/dict comprehensions and generator expressions."
msgstr ""

#: ../../development-tools/clinic.rst:1150
msgid "Tuple/list/set/dict literals."
msgstr ""

#: ../../development-tools/clinic.rst:1156
msgid "How to use return converters"
msgstr ""

#: ../../development-tools/clinic.rst:1158
msgid ""
"By default, the impl function Argument Clinic generates for you returns "
":c:type:`PyObject * <PyObject>`. But your C function often computes some "
"C type, then converts it into the :c:type:`!PyObject *` at the last "
"moment.  Argument Clinic handles converting your inputs from Python types"
" into native C types—why not have it convert your return value from a "
"native C type into a Python type too?"
msgstr ""

#: ../../development-tools/clinic.rst:1166
msgid ""
"That's what a \"return converter\" does.  It changes your impl function "
"to return some C type, then adds code to the generated (non-impl) "
"function to handle converting that value into the appropriate "
":c:type:`!PyObject *`."
msgstr ""

#: ../../development-tools/clinic.rst:1170
msgid ""
"The syntax for return converters is similar to that of parameter "
"converters. You specify the return converter like it was a return "
"annotation on the function itself, using ``->`` notation."
msgstr ""

#: ../../development-tools/clinic.rst:1174
msgid "For example:"
msgstr ""

#: ../../development-tools/clinic.rst:1187
msgid ""
"Return converters behave much the same as parameter converters; they take"
" arguments, the arguments are all keyword-only, and if you're not "
"changing any of the default arguments you can omit the parentheses."
msgstr ""

#: ../../development-tools/clinic.rst:1191
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, "
"the ``\"as\"`` should come before the return converter.)"
msgstr ""

#: ../../development-tools/clinic.rst:1194
msgid ""
"There's one additional complication when using return converters: how do "
"you indicate an error has occurred?  Normally, a function returns a valid"
" (non-``NULL``) pointer for success, and ``NULL`` for failure.  But if "
"you use an integer return converter, all integers are valid.  How can "
"Argument Clinic detect an error?  Its solution: each return converter "
"implicitly looks for a special value that indicates an error.  If you "
"return that value, and an error has been set (c:func:`PyErr_Occurred` "
"returns a true value), then the generated code will propagate the error."
"  Otherwise it will encode the value you return like normal."
msgstr ""

#: ../../development-tools/clinic.rst:1203
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr ""

#: ../../development-tools/clinic.rst:1217
msgid ""
"None of these take parameters. For all of these, return ``-1`` to "
"indicate error."
msgstr ""

#: ../../development-tools/clinic.rst:1220
msgid ""
"To see all the return converters Argument Clinic supports, along with "
"their parameters (if any), just run ``Tools/clinic/clinic.py "
"--converters`` for the full list."
msgstr ""

#: ../../development-tools/clinic.rst:1226
msgid "How to clone existing functions"
msgstr ""

#: ../../development-tools/clinic.rst:1228
msgid ""
"If you have a number of functions that look similar, you may be able to "
"use Clinic's \"clone\" feature.  When you clone an existing function, you"
" reuse:"
msgstr ""

#: ../../development-tools/clinic.rst:1232
msgid "its parameters, including"
msgstr ""

#: ../../development-tools/clinic.rst:1234
msgid "their names,"
msgstr ""

#: ../../development-tools/clinic.rst:1236
msgid "their converters, with all parameters,"
msgstr ""

#: ../../development-tools/clinic.rst:1238
msgid "their default values,"
msgstr ""

#: ../../development-tools/clinic.rst:1240
msgid "their per-parameter docstrings,"
msgstr ""

#: ../../development-tools/clinic.rst:1242
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr ""

#: ../../development-tools/clinic.rst:1245
msgid "its return converter."
msgstr ""

#: ../../development-tools/clinic.rst:1247
msgid ""
"The only thing not copied from the original function is its docstring; "
"the syntax allows you to specify a new docstring."
msgstr ""

#: ../../development-tools/clinic.rst:1250
msgid "Here's the syntax for cloning a function::"
msgstr ""

#: ../../development-tools/clinic.rst:1258
msgid ""
"(The functions can be in different modules or classes.  I wrote "
"``module.class`` in the sample just to illustrate that you must use the "
"full path to *both* functions.)"
msgstr ""

#: ../../development-tools/clinic.rst:1262
msgid ""
"Sorry, there's no syntax for partially cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""

#: ../../development-tools/clinic.rst:1265
msgid ""
"Also, the function you are cloning from must have been previously defined"
" in the current file."
msgstr ""

#: ../../development-tools/clinic.rst:1270
msgid "How to call Python code"
msgstr ""

#: ../../development-tools/clinic.rst:1272
msgid ""
"The rest of the advanced topics require you to write Python code which "
"lives inside your C file and modifies Argument Clinic's runtime state.  "
"This is simple: you simply define a Python block."
msgstr ""

#: ../../development-tools/clinic.rst:1276
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr ""

#: ../../development-tools/clinic.rst:1283
msgid ""
"All the code inside the Python block is executed at the time it's parsed."
"  All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""

#: ../../development-tools/clinic.rst:1287
msgid ""
"As an example, here's a Python block that adds a static integer variable "
"to the C code::"
msgstr ""

#: ../../development-tools/clinic.rst:1300
msgid "How to use the \"self converter\""
msgstr ""

#: ../../development-tools/clinic.rst:1302
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter "
"to the \"pointer to an instance\" you specified when you declared the "
"type.  However, you can override Argument Clinic's converter and specify "
"one yourself. Just add your own *self* parameter as the first parameter "
"in a block, and ensure that its converter is an instance of "
":class:`!self_converter` or a subclass thereof."
msgstr ""

#: ../../development-tools/clinic.rst:1311
msgid ""
"What's the point?  This lets you override the type of ``self``, or give "
"it a different default name."
msgstr ""

#: ../../development-tools/clinic.rst:1314
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you "
"only have one or two functions with the same type for ``self``, you can "
"directly use Argument Clinic's existing ``self`` converter, passing in "
"the type you want to use as the *type* parameter::"
msgstr ""

#: ../../development-tools/clinic.rst:1330
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
":class:`!self_converter` but overwriting the :py:attr:`!type` member::"
msgstr ""

#: ../../development-tools/clinic.rst:1352
msgid "How to use the \"defining class\" converter"
msgstr ""

#: ../../development-tools/clinic.rst:1354
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that "
"need to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec`"
" to associate a new heap type with a module.  You can now use "
":c:func:`PyType_GetModuleState` on the defining class to fetch the module"
" state, for example from a module method."
msgstr ""

#: ../../development-tools/clinic.rst:1360
msgid ""
"Example from :cpy-file:`Modules/zlibmodule.c`. First, ``defining_class`` "
"is added to the clinic input::"
msgstr ""

#: ../../development-tools/clinic.rst:1372
msgid ""
"After running the Argument Clinic tool, the following function signature "
"is generated::"
msgstr ""

#: ../../development-tools/clinic.rst:1382
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch "
"the module state::"
msgstr ""

#: ../../development-tools/clinic.rst:1388
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first "
"argument.  The argument will be of type ``PyTypeObject *``.  The argument"
" will not appear in the :py:attr:`!__text_signature__`."
msgstr ""

#: ../../development-tools/clinic.rst:1393
msgid ""
"The ``defining_class`` converter is not compatible with "
":py:meth:`!__init__` and :py:meth:`!__new__` methods, which cannot use "
"the :c:macro:`METH_METHOD` convention."
msgstr ""

#: ../../development-tools/clinic.rst:1397
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order"
" to fetch the module state from such methods, use "
":c:func:`PyType_GetModuleByDef` to look up the module and then "
":c:func:`PyModule_GetState` to fetch the module state.  Example from the "
"``setattro`` slot method in :cpy-file:`Modules/_threadmodule.c`::"
msgstr ""

#: ../../development-tools/clinic.rst:1412
msgid "See also :pep:`573`."
msgstr ""

#: ../../development-tools/clinic.rst:1418
msgid "How to write a custom converter"
msgstr ""

#: ../../development-tools/clinic.rst:1420
msgid ""
"A converter is a Python class that inherits from :py:class:`CConverter`. "
"The main purpose of a custom converter, is for parameters parsed with the"
" ``O&`` format unit --- parsing such a parameter means calling a "
":c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""

#: ../../development-tools/clinic.rst:1425
msgid ""
"Your converter class should be named :samp:`{ConverterName}_converter`. "
"By following this convention, your converter class will be automatically "
"registered with Argument Clinic, with its *converter name* being the name"
" of your converter class with the ``_converter`` suffix stripped off."
msgstr ""

#: ../../development-tools/clinic.rst:1430
msgid ""
"Instead of subclassing :py:meth:`!CConverter.__init__`, write a "
":py:meth:`!converter_init` method. :py:meth:`!converter_init` always "
"accepts a *self* parameter. After *self*, all additional parameters "
"**must** be keyword-only. Any arguments passed to the converter in "
"Argument Clinic will be passed along to your :py:meth:`!converter_init` "
"method. See :py:class:`CConverter` for a list of members you may wish to "
"specify in your subclass."
msgstr ""

#: ../../development-tools/clinic.rst:1439
msgid ""
"Here's the simplest example of a custom converter, from :cpy-"
"file:`Modules/zlibmodule.c`::"
msgstr ""

#: ../../development-tools/clinic.rst:1450
msgid ""
"This block adds a converter named ``ssize_t`` to Argument Clinic. "
"Parameters declared as ``ssize_t`` will be declared with type "
":c:type:`Py_ssize_t`, and will be parsed by the ``'O&'`` format unit, "
"which will call the :c:func:`!ssize_t_converter` converter C function. "
"``ssize_t`` variables automatically support default values."
msgstr ""

#: ../../development-tools/clinic.rst:1456
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom "
"converters in the CPython source tree; grep the C files for the string "
"``CConverter``."
msgstr ""

#: ../../development-tools/clinic.rst:1463
msgid "How to write a custom return converter"
msgstr ""

#: ../../development-tools/clinic.rst:1465
msgid ""
"Writing a custom return converter is much like writing a custom "
"converter.  Except it's somewhat simpler, because return converters are "
"themselves much simpler."
msgstr ""

#: ../../development-tools/clinic.rst:1469
msgid ""
"Return converters must subclass :py:class:`!CReturnConverter`. There are "
"no examples yet of custom return converters, because they are not widely "
"used yet.  If you wish to write your own return converter, please read "
":cpy-file:`Tools/clinic/clinic.py`, specifically the implementation of "
":py:class:`!CReturnConverter` and all its subclasses."
msgstr ""

#: ../../development-tools/clinic.rst:1478
msgid "How to convert ``METH_O`` and ``METH_NOARGS`` functions"
msgstr ""

#: ../../development-tools/clinic.rst:1480
msgid ""
"To convert a function using :c:macro:`METH_O`, make sure the function's "
"single argument is using the ``object`` converter, and mark the arguments"
" as positional-only::"
msgstr ""

#: ../../development-tools/clinic.rst:1492
msgid ""
"To convert a function using :c:macro:`METH_NOARGS`, just don't specify "
"any arguments."
msgstr ""

#: ../../development-tools/clinic.rst:1495
msgid ""
"You can still use a self converter, a return converter, and specify a "
"*type* argument to the object converter for :c:macro:`METH_O`."
msgstr ""

#: ../../development-tools/clinic.rst:1500
msgid "How to convert ``tp_new`` and ``tp_init`` functions"
msgstr ""

#: ../../development-tools/clinic.rst:1502
msgid ""
"You can convert :c:member:`~PyTypeObject.tp_new` and "
":c:member:`~PyTypeObject.tp_init` functions. Just name them ``__new__`` "
"or ``__init__`` as appropriate.  Notes:"
msgstr ""

#: ../../development-tools/clinic.rst:1506
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` "
"like it would by default.  It's just the name of the class, converted "
"into a valid C identifier."
msgstr ""

#: ../../development-tools/clinic.rst:1510
msgid "No :c:type:`PyMethodDef` ``#define`` is generated for these functions."
msgstr ""

#: ../../development-tools/clinic.rst:1512
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr ""

#: ../../development-tools/clinic.rst:1514
msgid "Use the docstring as the class docstring."
msgstr ""

#: ../../development-tools/clinic.rst:1516
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both "
"the ``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception "
"if it receives any.)"
msgstr ""

#: ../../development-tools/clinic.rst:1524
msgid "How to change and redirect Clinic's output"
msgstr ""

#: ../../development-tools/clinic.rst:1526
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you "
"can buffer up its output for printing later (or earlier!), or write its "
"output to a separate file.  You can also add a prefix or suffix to every "
"line of Clinic's generated output."
msgstr ""

#: ../../development-tools/clinic.rst:1532
msgid ""
"While changing Clinic's output in this manner can be a boon to "
"readability, it may result in Clinic code using types before they are "
"defined, or your code attempting to use Clinic-generated code before it "
"is defined. These problems can be easily solved by rearranging the "
"declarations in your file, or moving where Clinic's generated code goes."
"  (This is why the default behavior of Clinic is to output everything "
"into the current block; while many people consider this hampers "
"readability, it will never require rearranging your code to fix "
"definition-before-use problems.)"
msgstr ""

#: ../../development-tools/clinic.rst:1541
msgid "Let's start with defining some terminology:"
msgstr ""

#: ../../development-tools/clinic.rst:1568
msgid "*field*"
msgstr ""

#: ../../development-tools/clinic.rst:1544
msgid ""
"A field, in this context, is a subsection of Clinic's output. For "
"example, the ``#define`` for the :c:type:`PyMethodDef` structure is a "
"field, called ``methoddef_define``.  Clinic has seven different fields it"
" can output per function definition:"
msgstr ""

#: ../../development-tools/clinic.rst:1559
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the"
" docstring, or the methoddef structure) and ``\"<b>\"`` represents what "
"kind of statement the field is.  Field names that end in "
"``\"_prototype\"`` represent forward declarations of that thing, without "
"the actual body/data of the thing; field names that end in "
"``\"_definition\"`` represent the actual definition of the thing, with "
"the body/data of the thing.  (``\"methoddef\"`` is special, it's the only"
" one that ends with ``\"_define\"``, representing that it's a "
"preprocessor #define.)"
msgstr ""

#: ../../development-tools/clinic.rst:1602
msgid "*destination*"
msgstr ""

#: ../../development-tools/clinic.rst:1571
msgid ""
"A destination is a place Clinic can write output to.  There are five "
"built-in destinations:"
msgstr ""

#: ../../development-tools/clinic.rst:1576
#: ../../development-tools/clinic.rst:1651
#: ../../development-tools/clinic.rst:1729
msgid "``block``"
msgstr ""

#: ../../development-tools/clinic.rst:1575
msgid ""
"The default destination: printed in the output section of the current "
"Clinic block."
msgstr ""

#: ../../development-tools/clinic.rst:1582
#: ../../development-tools/clinic.rst:1678
#: ../../development-tools/clinic.rst:1732
msgid "``buffer``"
msgstr ""

#: ../../development-tools/clinic.rst:1579
msgid ""
"A text buffer where you can save text for later.  Text sent here is "
"appended to the end of any existing text.  It's an error to have any text"
" left in the buffer when Clinic finishes processing a file."
msgstr ""

#: ../../development-tools/clinic.rst:1593
#: ../../development-tools/clinic.rst:1664
#: ../../development-tools/clinic.rst:1758
msgid "``file``"
msgstr ""

#: ../../development-tools/clinic.rst:1585
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. "
"The filename chosen for the file is ``{basename}.clinic{extension}``, "
"where ``basename`` and ``extension`` were assigned the output from "
"``os.path.splitext()`` run on the current file.  (Example: the ``file`` "
"destination for :file:`_pickle.c` would be written to "
":file:`_pickle.clinic.c`.)"
msgstr ""

#: ../../development-tools/clinic.rst:1592
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in*"
" **the generated file!**"
msgstr ""

#: ../../development-tools/clinic.rst:1598
#: ../../development-tools/clinic.rst:1691
#: ../../development-tools/clinic.rst:1762
msgid "``two-pass``"
msgstr ""

#: ../../development-tools/clinic.rst:1596
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even "
"from Clinic blocks *after* the dumping point."
msgstr ""

#: ../../development-tools/clinic.rst:1602
#: ../../development-tools/clinic.rst:1725
msgid "``suppress``"
msgstr ""

#: ../../development-tools/clinic.rst:1601
msgid "The text is suppressed—thrown away."
msgstr ""

#: ../../development-tools/clinic.rst:1604
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr ""

#: ../../development-tools/clinic.rst:1606
msgid "The first new directive is ``dump``:"
msgstr ""

#: ../../development-tools/clinic.rst:1612
msgid ""
"This dumps the current contents of the named destination into the output "
"of the current block, and empties it.  This only works with ``buffer`` "
"and ``two-pass`` destinations."
msgstr ""

#: ../../development-tools/clinic.rst:1616
msgid ""
"The second new directive is ``output``.  The most basic form of "
"``output`` is like this:"
msgstr ""

#: ../../development-tools/clinic.rst:1623
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""

#: ../../development-tools/clinic.rst:1627
msgid "``output`` has a number of other functions:"
msgstr ""

#: ../../development-tools/clinic.rst:1636
msgid ""
"``output push`` and ``output pop`` allow you to push and pop "
"configurations on an internal configuration stack, so that you can "
"temporarily modify the output configuration, then easily restore the "
"previous configuration.  Simply push before your change to save the "
"current configuration, then pop when you wish to restore the previous "
"configuration."
msgstr ""

#: ../../development-tools/clinic.rst:1643
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr ""

#: ../../development-tools/clinic.rst:1647
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr ""

#: ../../development-tools/clinic.rst:1650
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""

#: ../../development-tools/clinic.rst:1654
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then"
" ``#include`` this file near the top of your file. You may need to "
"rearrange your file to make this work, though usually this just means "
"creating forward declarations for various ``typedef`` and "
"``PyTypeObject`` definitions."
msgstr ""

#: ../../development-tools/clinic.rst:1660
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""

#: ../../development-tools/clinic.rst:1664
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr ""

#: ../../development-tools/clinic.rst:1667
msgid ""
"Save up most of the output from Clinic, to be written into your file near"
" the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for"
" your module or builtin type; these are normally very near the end.  "
"Using ``buffer`` may require even more editing than ``file``, if your "
"file has static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""

#: ../../development-tools/clinic.rst:1676
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""

#: ../../development-tools/clinic.rst:1681
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar "
"to the ``buffer`` preset, but may require less editing than ``buffer``.  "
"Dump the ``two-pass`` buffer near the top of your file, and dump the "
"``buffer`` near the end just like you would when using the ``buffer`` "
"preset."
msgstr ""

#: ../../development-tools/clinic.rst:1688
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to "
"``buffer``."
msgstr ""

#: ../../development-tools/clinic.rst:1702
msgid "``partial-buffer``"
msgstr ""

#: ../../development-tools/clinic.rst:1694
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, "
"only writing the really big chunks of generated code to ``buffer``. This "
"avoids the definition-before-use problem of ``buffer`` completely, at the"
" small cost of having slightly more stuff in the block's output. Dump the"
" ``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""

#: ../../development-tools/clinic.rst:1701
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and"
" ``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""

#: ../../development-tools/clinic.rst:1704
msgid "The third new directive is ``destination``:"
msgstr ""

#: ../../development-tools/clinic.rst:1710
msgid "This performs an operation on the destination named ``name``."
msgstr ""

#: ../../development-tools/clinic.rst:1712
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr ""

#: ../../development-tools/clinic.rst:1714
msgid "The ``new`` subcommand works like this:"
msgstr ""

#: ../../development-tools/clinic.rst:1720
msgid "This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr ""

#: ../../development-tools/clinic.rst:1722
msgid "There are five destination types:"
msgstr ""

#: ../../development-tools/clinic.rst:1725
msgid "Throws the text away."
msgstr ""

#: ../../development-tools/clinic.rst:1728
msgid "Writes the text to the current block.  This is what Clinic originally did."
msgstr ""

#: ../../development-tools/clinic.rst:1732
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr ""

#: ../../development-tools/clinic.rst:1735
msgid ""
"A text file.  The file destination takes an extra argument, a template to"
" use for building the filename, like so::"
msgstr ""

#: ../../development-tools/clinic.rst:1740
msgid ""
"The template can use three strings internally that will be replaced by "
"bits of the filename:"
msgstr ""

#: ../../development-tools/clinic.rst:1743
msgid "``{path}``"
msgstr ""

#: ../../development-tools/clinic.rst:1744
msgid "The full path to the file, including directory and full filename."
msgstr ""

#: ../../development-tools/clinic.rst:1745
msgid "``{dirname}``"
msgstr ""

#: ../../development-tools/clinic.rst:1746
msgid "The name of the directory the file is in."
msgstr ""

#: ../../development-tools/clinic.rst:1747
msgid "``{basename}``"
msgstr ""

#: ../../development-tools/clinic.rst:1748
msgid "Just the name of the file, not including the directory."
msgstr ""

#: ../../development-tools/clinic.rst:1750
msgid "``{basename_root}``"
msgstr ""

#: ../../development-tools/clinic.rst:1750
msgid ""
"Basename with the extension clipped off (everything up to but not "
"including the last '.')."
msgstr ""

#: ../../development-tools/clinic.rst:1754
msgid "``{basename_extension}``"
msgstr ""

#: ../../development-tools/clinic.rst:1753
msgid ""
"The last '.' and everything after it.  If the basename does not contain a"
" period, this will be the empty string."
msgstr ""

#: ../../development-tools/clinic.rst:1756
msgid ""
"If there are no periods in the filename, ``{basename}`` and "
"``{filename}`` are the same, and ``{extension}`` is empty.  "
"``{basename}{extension}`` is always exactly the same as ``{filename}``."
msgstr ""

#: ../../development-tools/clinic.rst:1761
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr ""

#: ../../development-tools/clinic.rst:1764
msgid "The ``clear`` subcommand works like this:"
msgstr ""

#: ../../development-tools/clinic.rst:1770
msgid ""
"It removes all the accumulated text up to this point in the destination. "
"(I don't know what you'd need this for, but I thought maybe it'd be "
"useful while someone's experimenting.)"
msgstr ""

#: ../../development-tools/clinic.rst:1774
msgid "The fourth new directive is ``set``:"
msgstr ""

#: ../../development-tools/clinic.rst:1781
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is"
" a string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of "
"Clinic's output."
msgstr ""

#: ../../development-tools/clinic.rst:1785
msgid "Both of these support two format strings:"
msgstr ""

#: ../../development-tools/clinic.rst:1788
msgid "``{block comment start}``"
msgstr ""

#: ../../development-tools/clinic.rst:1788
msgid "Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr ""

#: ../../development-tools/clinic.rst:1791
msgid "``{block comment end}``"
msgstr ""

#: ../../development-tools/clinic.rst:1791
msgid "Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr ""

#: ../../development-tools/clinic.rst:1793
msgid ""
"The final new directive is one you shouldn't need to use directly, called"
" ``preserve``:"
msgstr ""

#: ../../development-tools/clinic.rst:1800
msgid ""
"This tells Clinic that the current contents of the output should be kept,"
" unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its "
"existing checksum functionality to ensure the file was not modified by "
"hand before it gets overwritten."
msgstr ""

#: ../../development-tools/clinic.rst:1807
msgid "How to use the ``#ifdef`` trick"
msgstr ""

#: ../../development-tools/clinic.rst:1809
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing "
"code probably looks like this::"
msgstr ""

#: ../../development-tools/clinic.rst:1820
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code"
" will have:"
msgstr ""

#: ../../development-tools/clinic.rst:1829
msgid ""
"In this scenario, you should enclose the body of your impl function "
"inside the ``#ifdef``, like so::"
msgstr ""

#: ../../development-tools/clinic.rst:1843
msgid ""
"Then, remove those three lines from the :c:type:`PyMethodDef` structure, "
"replacing them with the macro Argument Clinic generated:"
msgstr ""

#: ../../development-tools/clinic.rst:1850
msgid ""
"(You can find the real name for this macro inside the generated code. Or "
"you can calculate it yourself: it's the name of your function as defined "
"on the first line of your block, but with periods changed to underscores,"
" uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""

#: ../../development-tools/clinic.rst:1855
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? "
"The ``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""

#: ../../development-tools/clinic.rst:1858
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that "
"the Argument Clinic block might be deactivated by the ``#ifdef``.  When "
"that happens, it generates a little extra code that looks like this::"
msgstr ""

#: ../../development-tools/clinic.rst:1866
msgid ""
"That means the macro always works.  If the function is defined, this "
"turns into the correct structure, including the trailing comma.  If the "
"function is undefined, this turns into nothing."
msgstr ""

#: ../../development-tools/clinic.rst:1870
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic "
"put this extra code when using the \"block\" output preset?  It can't go "
"in the output block, because that could be deactivated by the ``#ifdef``."
"  (That's the whole point!)"
msgstr ""

#: ../../development-tools/clinic.rst:1874
msgid ""
"In this situation, Argument Clinic writes the extra code to the "
"\"buffer\" destination. This may mean that you get a complaint from "
"Argument Clinic:"
msgstr ""

#: ../../development-tools/clinic.rst:1882
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block "
"that Argument Clinic added to your file (it'll be at the very bottom), "
"then move it above the :c:type:`PyMethodDef` structure where that macro "
"is used."
msgstr ""

#: ../../development-tools/clinic.rst:1888
msgid "How to use Argument Clinic in Python files"
msgstr ""

#: ../../development-tools/clinic.rst:1890
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files."
" There's no point to using Argument Clinic blocks, of course, as the "
"output wouldn't make any sense to the Python interpreter.  But using "
"Argument Clinic to run Python blocks lets you use Python as a Python "
"preprocessor!"
msgstr ""

#: ../../development-tools/clinic.rst:1895
msgid ""
"Since Python comments are different from C comments, Argument Clinic "
"blocks embedded in Python files look slightly different.  They look like "
"this:"
msgstr ""

#: ../../development-tools/clinic.rst:1910
msgid "How to use the Limited C API"
msgstr ""

#: ../../development-tools/clinic.rst:1912
msgid ""
"If Argument Clinic :term:`input` is located within a C source file that "
"contains ``#define Py_LIMITED_API``, Argument Clinic will generate C code"
" that uses the :ref:`Limited API <limited-c-api>` to parse arguments. The"
" advantage of this is that the generated code will not use private "
"functions. However, this *can* result in Argument Clinic generating less "
"efficient code in some cases. The extent of the performance penalty will "
"depend on the parameters (types, number, etc.)."
msgstr ""

#: ../../development-tools/clinic.rst:1926
msgid "How to override the generated signature"
msgstr ""

#: ../../development-tools/clinic.rst:1928
msgid ""
"You can use the ``@text_signature`` directive to override the default "
"generated signature in the docstring. This can be useful for complex "
"signatures that Argument Clinic cannot handle. The ``@text_signature`` "
"directive takes one argument: the custom signature as a string. The "
"provided signature is copied verbatim to the generated docstring."
msgstr ""

#: ../../development-tools/clinic.rst:1935
msgid "Example from :cpy-file:`Objects/codeobject.c`::"
msgstr ""

#: ../../development-tools/clinic.rst:1948
msgid "The generated docstring ends up looking like this:"
msgstr ""

#: ../../development-tools/clinic.rst:1961
msgid "How to use critical sections with Argument Clinic"
msgstr ""

#: ../../development-tools/clinic.rst:1963
msgid ""
"You can use the ``@critical_section`` directive to instruct Argument "
"Clinic to wrap the call to the \"impl\" function in a \"Python critical "
"section\". In builds of CPython without the Global Interpreter Lock "
"(\"GIL\"), critical sections are required in order to achieve thread "
"safety without causing deadlocks between threads. When a critical section"
" is entered into, a per-object lock associated with the first argument of"
" the decorated function is acquired. The lock is released on exiting the "
"critical section."
msgstr ""

#: ../../development-tools/clinic.rst:1972
msgid ""
"Python critical sections are no-ops in builds of CPython with the GIL. "
"See :cpy-file:`Include/internal/pycore_critical_section.h` and :pep:`PEP "
"703 <703#python-critical-sections>` for more details about critical "
"sections."
msgstr ""

#: ../../development-tools/clinic.rst:1977
msgid "Example from :cpy-file:`Modules/_io/bufferedio.c`::"
msgstr ""

#: ../../development-tools/clinic.rst:1984
msgid "The generated glue code looks like this:"
msgstr ""

#: ../../development-tools/clinic.rst:2008
msgid "How to deprecate passing parameters positionally or by keyword"
msgstr ""

#: ../../development-tools/clinic.rst:2010
msgid ""
"Argument Clinic provides syntax that makes it possible to generate code "
"that deprecates passing :term:`arguments <argument>` for positional-or-"
"keyword :term:`parameters <parameter>` positionally or by keyword. For "
"example, say we've got a module-level function :py:func:`!foo.myfunc` "
"that has five parameters: a positional-only parameter *a*, three "
"positional-or-keyword parameters *b*, *c* and *d*, and a keyword-only "
"parameter *e*::"
msgstr ""

#: ../../development-tools/clinic.rst:2030
msgid ""
"We now want to make the *b* parameter positional-only and the *d* "
"parameter keyword-only; however, we'll have to wait two releases before "
"making these changes, as mandated by Python's backwards-compatibility "
"policy (see :pep:`387`). For this example, imagine we're in the "
"development phase for Python 3.12: that means we'll be allowed to "
"introduce deprecation warnings in Python 3.12 whenever an argument for "
"the *b* parameter is passed by keyword or an argument for the *d* "
"parameter is passed positionally, and we'll be allowed to make them "
"positional-only and keyword-only respectively in Python 3.14 at the "
"earliest."
msgstr ""

#: ../../development-tools/clinic.rst:2041
msgid ""
"We can use Argument Clinic to emit the desired deprecation warnings using"
" the ``[from ...]`` syntax, by adding the line ``/ [from 3.14]`` right "
"below the *b* parameter and adding the line ``* [from 3.14]`` right above"
" the *d* parameter::"
msgstr ""

#: ../../development-tools/clinic.rst:2060
msgid ""
"Next, regenerate Argument Clinic code (``make clinic``), and add unit "
"tests for the new behaviour."
msgstr ""

#: ../../development-tools/clinic.rst:2063
msgid ""
"The generated code will now emit a :exc:`DeprecationWarning` when an "
":term:`argument` for the :term:`parameter` *d* is passed positionally "
"(e.g ``myfunc(1, 2, 3, 4, e=5)``) or an argument for the parameter *b* is"
" passed by keyword (e.g ``myfunc(1, b=2, c=3, d=4, e=5)``). C "
"preprocessor directives are also generated for emitting compiler warnings"
" if the ``[from ...]`` lines have not been removed from the Argument "
"Clinic input when the deprecation period is over, which means when the "
"alpha phase of the specified Python version kicks in."
msgstr ""

#: ../../development-tools/clinic.rst:2072
msgid ""
"Let's return to our example and skip ahead two years: Python 3.14 "
"development has now entered the alpha phase, but we forgot all about "
"updating the Argument Clinic code for :py:func:`!myfunc`! Luckily for us,"
" compiler warnings are now generated:"
msgstr ""

#: ../../development-tools/clinic.rst:2085
msgid ""
"We now close the deprecation phase by making *a* positional-only and *c* "
"keyword-only; replace the ``/ [from ...]`` line below *b* with the ``/`` "
"from the line below *a* and the ``* [from ...]`` line above *d* with the "
"``*`` from the line above *e*::"
msgstr ""

#: ../../development-tools/clinic.rst:2103
msgid ""
"Finally, run ``make clinic`` to regenerate the Argument Clinic code, and "
"update your unit tests to reflect the new behaviour."
msgstr ""

#: ../../development-tools/clinic.rst:2108
msgid ""
"If you forget to update your input block during the alpha and beta "
"phases, the compiler warning will turn into a compiler error when the "
"release candidate phase begins."
msgstr ""

